Ниже представлен ряд вопросов по SQL.

Это те вопросы, которые интервьюеры часто задают на собеседованиях. Я старался подобрать как можно больше вопросов, которые задают аналитикам данных.
После каждого вопроса дан ответ. Но для самопроверки попробуйте сперва ответить сами, не подглядывая в шпаргалку.

![Интервью SQL](https://github.com/TalkoDenis/interviews/blob/main/SQL/Theory/%D0%93%D0%BE%D0%BC%D0%B5%D1%80.jpg)


#### Что такое SQL?
<details>
<summary>Ответ</summary>

_SQL (Structured Query Language)_ - язык структурированных запросов. Это стандартный язык для СУБД. Он особенно полезен при обработке организованных данных, состоящих из сущностей (переменных) и отношений между различными сущностями данных.
</details>

#### Что такое таблицы и поля?
<details>
<summary>Ответ</summary>

_Таблица_ - это организованный набор данных, хранящихся в виде строк и столбцов. Столбцы могут быть классифицированы как вертикальные поля, а строки - как горизонтальные.
_Поля_ - это колонки в таблице, предназначенные для хранения информации.
</details>

#### Что такое база данных?
<details>
<summary>Ответ</summary>
Можно дать несколько разных определений. Ниже представлены те, которые я считаю наиболее удачными.

_База данных_ - это совокупность данных, хранящихся и извлекаемых в цифровом виде из удалённой или локальной компьютерной системы.

_База данных_ - это упорядоченный набор структурированной информации или данных, которые обычно хранятся в электронном виде в компьютерной системе. База данных обычно управляется системой управления базами данных (СУБД).

_База данных_ - это совокупность данных, хранимых в соответствии со схемой данных, манипулирование которыми выполняют в соответствии с правилами средств моделирования данных
</details>

#### Что такое СУБД?
<details>
<summary>Ответ</summary>

_СУБД_ - Система Управления Базами Данных. СУБД - это системное программное обеспечение, ответственное за создание, поиск, обновление и управление базы данных. СУБД гарантирует, наши данные организованы и легкодоступны, выступая в качестве интерфейса между базой данных и её конечными пользователями.
</details>

#### Что такое РСУБД? В чём заключается её отличие от СУБД?
<details>
<summary>Ответ</summary>

_РСУБД_ - Реляционная Система Управления Базами Данных. Ключевое отличие по сравнению с СУБД в том, что РСУБД хранит данные в виде набора таблиц, и между общими полями этих таблиц могут существовать отношения. Большинство современных систем управления базами данных, таких как MySQL, Microsoft SQL Server, Oracle, IBM DB2 и Amazon Redshift, основаны на РСУБД.
</details>

#### Что такое нормализация?
<details>
<summary>Ответ</summary>

_Нормализация_ — это процесс организации данных в базе данных, включающий создание таблиц и установление отношений между ними в соответствии с правилами, которые обеспечивают защиту данных и делают базу данных более гибкой, устраняя избыточность и несогласованные зависимости.
</details>

#### Что такое денормализация?
<details>
<summary>Ответ</summary>

_Денормализация_ - это процесс обратный нормализации. При денормализации нормализованная схема преобразуется в схему, содержащую избыточную информацию. Производительность повышается за счет использования избыточности и обеспечения согласованности избыточных данных. Причиной выполнения денормализации являются накладные расходы, возникающие в процессоре запросов из-за чрезмерно нормализованной структуры.
</details>

#### Из каких подмножеств состоит SQL?
<details>
<summary>Ответ</summary>

_DDL (Data Definition Language, язык описания данных)_ — позволяет выполнять различные операции с базой данных, такие как CREATE (создание), ALTER (изменение) и DROP (удаление объектов).
_DML (Data Manipulation Language, язык управления данными)_ — позволяет получать доступ к данным и манипулировать ими, например, вставлять, обновлять, удалять и извлекать данные из базы данных.
_DCL (Data Control Language, язык контролирования данных)_ — позволяет контролировать доступ к базе данных. Пример — GRANT (предоставить права), REVOKE (отозвать права).
</details>

#### Расскажите про нормальные формы. Какие они бывают и чем отличаются?
<details>
<summary>Ответ</summary>

_Нормальная форма_ — требование, предъявляемое к структуре таблиц в теории реляционных баз данных для устранения из базы избыточных функциональных зависимостей между атрибутами (полями таблиц).
Всего существует шесть нормальных форм. Самая основная и наиболее часто используемая - третья нормальная форма (3НФ), по этой причине, тут будет дано определение только первых трёх нормальных форм. Для аналитика данных этого более чем достаточно.

_Первая нормальная форма_ - оношение находится в 1НФ, если все его атрибуты[^1] являются простыми, все используемые домены[^2] должны содержать только скалярные значения. Не должно быть повторений строк в таблице.

_Вторая нормальная форма_ - отношение находится во 2НФ, если оно находится в 1НФ и каждый не ключевой атрибут неприводимо зависит от первичного Ключа. Неприводимость означает, что в составе потенциального ключа отсутствует меньшее подмножество атрибутов, от которого можно также вывести данную функциональную зависимость.

_Третья нормальная форма_ - отношение находится в 3НФ, когда находится во 2НФ и каждый не ключевой атрибут нетранзитивно зависит от первичного ключа. Проще говоря, требуется выносить все не ключевые поля, содержимое которых может относиться к нескольким записям таблицы в отдельные таблицы.

_Нормальная форма Бойса-Кодда (НФБК)_ - это частная форма третьей нормальной формы.

Определение 3НФ не подходит для следующих отношений:
1) отношение имеет два или более потенциальных ключа;
2) два и более потенциальных ключа являются составными;
3) ключи пересекаются, т.е. имеют хотя бы один общий атрибут.

Для отношений, имеющих один потенциальный ключ (первичный), НФБК является 3НФ. Отношение находится в НФБК, когда каждая нетривиальная и неприводимая слева функциональная зависимость обладает потенциальным ключом в качестве детерминанта.

[^1]: Атрибут — свойство некоторой сущности. Часто называется полем таблицы.

[^2]: Домен атрибута — множество допустимых значений, которые может принимать атрибут.
</details>

#### Что такое первичный ключ?
<details>
<summary>Ответ</summary>

_Первичный ключ (Primary Key)_ предназначен для однозначной идентификации каждой записи в таблице и является строго уникальным (unique): две записи таблицы не могут иметь одинаковые значения первичного ключа. Нулевые значения (NULL) в качестве первичного ключа не допускаются. Если в качестве первичного ключа используется несколько полей, их называют составным ключом.
</details>

#### Когда используется первичный ключ?
<details>
<summary>Ответ</summary>
Первичный ключ используется в качестве основного ключа и может быть использован для связи с дочерней таблицей, содержащей внешний ключ.
</details>

#### Что такое внешний ключ?
<details>
<summary>Ответ</summary>

_Внешний ключ (Foreign Key)_ является атрибутом ограничения и обеспечивает связь двух таблиц. По сути, это поле или несколько полей, которые ссылаются на первичный ключ в родительской таблице.
</details>

#### Чем NULL отличается от 0?
<details>
<summary>Ответ</summary>
0 - это число.
NULL - это не число, а также NULL не является значением пустой строки. NULL используется для указания того, что данные отсутствуют, неизвестны, неприменимы. NULL не равен ничему, даже другому NULL.
</details>

#### Перечислите различные типы связей.
<details>
<summary>Ответ</summary>

_Один-к-одному (One-to-One)_ - этот тип может быть определён как отношение между двумя таблицами, где каждая запись в одной таблице связана максимум с одной записью в другой таблице.
_Один-ко-многим и Многие-к-одному (One-to-Many & Many-to-One)_ - это наиболее часто используемое отношение, когда запись в таблице связана с несколькими записями в другой таблице.
_Многие-ко-многим (Many-to-Many)_ - этот тип используется в случаях, когда для определения отношения требуется несколько экземпляров с обеих сторон.
</details>


#### Что такое схема "Звезда" и "Снежинка"? Опишите их сходства и различия.
<details>
<summary>Ответ</summary>
Схемы «звезда» и «снежинка» — это два способа структурировать хранилище данных.

Схема «звезда» (star schema) — специальная организация реляционных таблиц, удобная для хранения многомерных показателей. Лежит в основе реляционного OLAP.

Схема типа «звезда» имеет централизованное хранилище данных, которое хранится в таблице фактов (fact table). Схема разбивает таблицу фактов на ряд денормализованных таблиц измерений (dimension table). Таблица фактов содержит агрегированные данные, которые будут использоваться для составления отчетов, а таблица измерений описывает хранимые данные.

Денормализованные проекты менее сложны, потому что данные сгруппированы. Таблица фактов использует только одну ссылку для присоединения к каждой таблице измерений. Более простая конструкция звездообразной схемы значительно упрощает написание сложных запросов.

Модель данных состоит из двух типов таблиц: одной таблицы фактов  — центр «звезды» — и нескольких таблиц измерений по числу измерений в модели данных — лучи «звезды».



Пример схемы "звёзда":
Таблица фактов содержит одну или несколько колонок типа DECIMAL, дающих числовую характеристику какому-то аспекту предметной области (например, объём продаж для торговой компании или сумма платежей для банка), и несколько целочисленных колонок-ключей для доступа к таблицам измерений. В таблицы фактов данные должны оперативно записываться в случае изменений.

Таблицы измерений расшифровывают ключи, на которые ссылается таблица фактов; например, таблица «products» измерения «товары» базы данных торговой компании может содержать сведения о названии товара, его производителе, типе товара. За счёт использования специальной структуры таблицы измерений реализуется иерархия измерений, в том числе ветвящаяся.

Обычно данные в таблицах-измерениях денормализованы: ценой несколько неэффективного использования дискового пространства удается уменьшить число участвующих в операции соединения таблиц, что обычно приводит к сильному уменьшению времени выполнения запроса. Иногда, тем не менее, требуется произвести нормализацию таблиц-измерений. Такая схема носит название «снежинка» (snowflake schema).

SQL-запрос к схеме «звезда» обычно содержит в себе:

- одно или несколько соединений таблицы фактов с таблицами измерений;
- несколько фильтров (оператор WHERE), применяемых к таблице фактов или таблицам измерений;
- группировку и агрегирование по требуемым элементам иерархии измерений (dimension elements).




Схема типа «снежинка» (snowflake schema) отличается тем, что использует нормализованные данные. Нормализация означает эффективную организацию данных так, чтобы все зависимости данных были определены, и каждая таблица содержала минимум избыточности. Таким образом, отдельные таблицы измерений разветвляются на отдельные таблицы измерений.

Схема «снежинки» использует меньше дискового пространства и лучше сохраняет целостность данных. Основным недостатком является сложность запросов, необходимых для доступа к данным — каждый запрос должен пройти несколько соединений таблиц, чтобы получить соответствующие данные.




Схема снежинки (snowflake schema) получила своё название за свою форму, в виде которой отображается логическая схема таблиц в многомерной базе данных. Так же как и в схеме звезды, схема снежинки представлена централизованной таблицей фактов, соединенной с таблицами измерений. Отличием является то, что здесь таблицы измерений нормализованы с рядом других связанных измерительных таблиц, — в то время как в схеме звезды таблицы измерений полностью денормализованы, с каждым измерением представленным в виде единой таблицы, без соединений на связанные таблицы в схеме снежинки. Чем больше степень нормализации таблиц измерений, тем сложнее выглядит структура схемы снежинки. Создаваемый «эффект снежинки» затрагивает только таблицы измерений, и не применим к таблицам фактов.

Использование
Схема снежинки, также как и схема звезды, наиболее часто встречается в таких хранилищах данных, для которых скорость получения данных более важна, чем эффективность манипуляции ими. Следовательно, таблицы должны быть нормализованы в малой степени, и зачастую разрабатываются с применением не выше третьего уровня нормализации.

Решение в сторону использования схемы звезды или же схемы снежинки, обуславливается относительной мощностью платформы БД, и инструментария для реализации запросов. Схема звезды подходит окружению, в котором инструментарий реализации запросов предоставляет пользователям широкий доступ к структуре таблиц, а также в окружениях, где большинство запросов просты по своей природе. Схема снежинки более подходит для случаев применения более сложного инструментария для реализации запросов, который в большей степени изолирует пользователей от детальной структуры таблиц, а также для среды с множеством запросов сложной структуры.



Для простоты понимания можно считать, что "снежинка" состоит из нескольких "звёзд".

Примеры схем звезда и снежинка.

![image](https://github.com/TalkoDenis/interviews/blob/main/SQL/Theory/%D0%97%D0%B2%D0%B5%D0%B7%D0%B4%D0%B0%20%D0%B8%20%D1%81%D0%BD%D0%B5%D0%B6%D0%B8%D0%BD%D0%BA%D0%B0%202.gif)


![image](https://github.com/TalkoDenis/interviews/blob/main/SQL/Theory/%D0%97%D0%B2%D0%B5%D0%B7%D0%B4%D0%B0%20%D0%B8%20%D1%81%D0%BD%D0%B5%D0%B6%D0%B8%D0%BD%D0%BA%D0%B0.gif)

</details>

#### Что такое таблица фактов и таблица измерений?
<details>
<summary>Ответ</summary>
Таблицы фактов (fact table) — это таблицы, записи которых являются неизменяемыми "фактами", такими как журналы служб и сведения об измерениях. Записи постепенно добавляются в таблицу потоковой передачей или большими блоками. Записи остаются там до тех пор, пока они не будут удалены из-за затрат или из-за потери их стоимости. В противном случае записи никогда не обновляются.

Данные сущностей иногда хранятся в фактических таблицах, где данные сущности изменяются медленно. Например, данные о какой-либо физической сущности, такой как офисное оборудование, которое редко меняет расположение. Так как данные в Kusto являются неизменяемыми, обычно каждая таблица содержит два столбца:

Столбец идентификатора (string), который идентифицирует сущность
Столбец метки времени последнего изменения (datetime)
Затем извлекается только последняя запись для каждого удостоверения сущности.


Таблица фактов — является основной таблицей хранилища данных[1][2][3][4]. Как правило, она содержит сведения об объектах или событиях, совокупность которых будет в дальнейшем анализироваться. Обычно говорят о четырёх наиболее часто встречающихся типах фактов. К ним относятся:

факты, связанные с транзакциями (англ. Transaction facts). Они основаны на отдельных событиях (типичными примерами которых являются телефонный звонок или снятие денег со счёта с помощью банкомата);
факты, связанные с «моментальными снимками» (англ. Snapshot facts). Основаны на состоянии объекта (например, банковского счёта) в определённые моменты времени, например на конец дня или месяца. Типичными примерами таких фактов являются объём продаж за день или дневная выручка;
факты, связанные с элементами документа (англ. Line-item facts). Основаны на том или ином документе (например, счёте за товар или услугу) и содержат подробную информацию об элементах этого документа (например, количестве, цене, проценте скидки);
факты, связанные с событиями или состоянием объекта (англ. Event or state facts). Представляют возникновение события без подробностей о нём (например, просто факт продажи или факт отсутствия таковой без иных подробностей).
Таблица фактов, как правило, содержит уникальный составной ключ, объединяющий первичные ключи таблиц измерений. Чаще всего это целочисленные значения либо значения типа «дата/время» в целочисленном формате — ведь таблица фактов может содержать сотни тысяч или даже миллионы записей, и хранить в ней повторяющиеся текстовые описания, как правило, невыгодно — лучше поместить их в меньшие по объёму таблицы измерений. При этом как ключевые, так и некоторые неключевые поля должны соответствовать будущим измерениям OLAP-куба. Помимо этого, таблица фактов содержит одно или несколько числовых полей, на основании которых в дальнейшем будут получены агрегатные данные.

Для многомерного анализа пригодны таблицы фактов, содержащие как можно более подробные данные (то есть соответствующие членам нижних уровней иерархии соответствующих измерений). В данном случае предпочтительнее взять за основу факты продажи товаров отдельным заказчикам, а не суммы продаж для разных стран — последние все равно будут вычислены OLAP-средством, в случае использования такового. Исключение можно сделать, пожалуй, только для клиентских OLAP-средств, поскольку в силу ряда ограничений они не могут манипулировать большими объёмами данных.

В таблице фактов нет никаких сведений о том, как группировать записи при вычислении агрегатных данных. Например, в ней есть идентификаторы продуктов или клиентов, но отсутствует информация о том, к какой категории относится данный продукт или в каком городе находится данный клиент. Эти сведения, в дальнейшем используемые для построения иерархий в измерениях куба, содержатся в таблицах измерений. В случае построения отчетов напрямую из хранилища данных, минуя промежуточный шаг создания OLAP-кубов, также могут использоваться так называемые агрегатные таблицы фактов, содержащие крупнозернистую информацию, например суммарные траты покупателя в выбранном магазине за месяц, вместо или в дополнение к детальной таблице фактов с подробной информацией о каждой покупке.




Таблицы измерений
Таблицы измерений:

Хранение ссылочных данных, таких как таблицы подстановки, от идентификатора сущности до ее свойств
Хранение данных, подобных snapshot, в таблицах, все содержимое которых изменяется в одной транзакции
Таблицы измерений не регулярно помечаются с новыми данными. Вместо этого все содержимое данных обновляется одновременно с помощью таких операций, как .set-or-replace, .move extents или .rename tables.

Иногда таблицы измерений могут быть производными от таблиц фактов. Этот процесс можно выполнить с помощью политики обновления в таблице фактов с запросом к таблице, которая принимает последнюю запись для каждой сущности.

Различения таблиц фактов и измерений
В Kusto существуют процессы, которые различают таблицы фактов и таблицы измерений. Один из них — непрерывный экспорт.

Эти механизмы гарантированно обрабатывают данные в фактических таблицах точно один раз. Они полагаются на механизм курсора базы данных .

Например, при каждом выполнении задания непрерывного экспорта экспортируются все записи, которые были приема с момента последнего обновления курсора базы данных. Задания непрерывного экспорта должны различать таблицы фактов и таблицы измерений. Таблицы фактов обрабатывают только недавно обработанные данные, а таблицы измерений используются в качестве подстановок. Таким образом, необходимо учитывать всю таблицу.

Невозможно пометить таблицу как таблицу фактов или таблицу измерений. Способ приема данных в таблицу и способ ее использования определяет ее тип.





Таблица измерений (англ. dimension table) — таблица в структуре многомерной базы данных, которая содержит атрибуты событий, сохраненных в таблице фактов. Атрибуты представляют собой текстовые или иные описания, логически объединенные в одно целое. Например, имя покупателя может являться атрибутом в таблице измерений покупателей, а наименование товара, — в таблице измерений товаров. В то время как сумма транзакции является величиной аддитивной, и её значение должно храниться в таблице фактов.

Таблица фактов связана с таблицами измерений с помощью внешнего ключа.

С течением времени значения атрибутов строки в таблице измерений могут измениться. Например, юридический адрес компании или отдел компании, в котором работает сотрудник. Для отслеживания и обработки в таком случае используют медленно меняющиеся измерения[1]. Есть несколько типов обработки таких изменений:

Первый тип: Перезаписать старые значения.
Второй тип: Добавить новую строку, содержащую новые значения, сохраняя бизнес-ключ для различия строк.
Третий тип: Добавить новый атрибут в существующую строку.

</details>



#### Какая разница между UNION и UNION ALL?
<details>
<summary>Ответ</summary>
Оба эти выражения используются, чтобы объединить результаты нескольких независимых друг от друга запросов. Разница заключается в том, что, если в результатах запросов есть одинаковые строки, то UNION удалит дубликаты, оставив только одну из таких строк. UNION ALL просто объединит результаты запросов, не обращая внимания на дубликаты.
</details>



#### Зачем нужны операторы MINUS и INTERSECT?
<details>
<summary>Ответ</summary>
Оператор MINUS отвечает за вычитание результатов одного подзапроса из результатов второго подзапроса;
Оператор INTERSECT отвечает за пересечение строк из обоих подзапросов.
  
Перед выполнением любого из приведенных выше инструкций в SQL, необходимо выполнить определенные условия:

1. Каждый оператор SELECT в предложении должен иметь одинаковое количество столбцов;
2. Столбцы также должны иметь аналогичные типы данных;
3. Столбцы в каждой инструкции SELECT обязательно должны иметь одинаковый порядок.
</details>


#### Какая разница между выражениями WHERE и HAVING?
<details>
<summary>Ответ</summary>
Ну и наконец, вопрос, который задают практически на каждом собеседовании по базам данных: про HAVING.
Выражения WHERE и HAVING используются для фильтрации результата запроса и ожидают после себя некоторое условие, по которому нужно отфильтровать данные. Но, если WHERE работает само по себе и фильтрует данные каждой строки результата по отдельности, то выражение HAVING имеет смысл только в сочетании с выражением GROUP BY и фильтрует уже сгруппированные значения.
</details>


#### Для чего используется ключевое слово ORDER BY?
<details>
<summary>Ответ</summary>
Для сортировки данных в порядке возрастания (ASC) или убывания (DESC).
</details>


#### Назовите четыре основных типа соединения в SQL
<details>
<summary>Ответ</summary>
Чтобы объединить две таблицы в одну, следует использовать оператор JOIN. Соединение таблиц может быть внутренним (INNER) или внешним (OUTER), причём внешнее соединение может быть левым (LEFT), правым (RIGHT) или полным (FULL).

INNER JOIN — получение записей с одинаковыми значениями в обеих таблицах, т.е. получение пересечения таблиц.
FULL OUTER JOIN — объединяет записи из обеих таблиц (если условие объединения равно true) и дополняет их всеми записями из обеих таблиц, которые не имеют совпадений. Для записей, которые не имеют совпадений из другой таблицы, недостающее поле будет иметь значение NULL.
LEFT JOIN — возвращает все записи, удовлетворяющие условию объединения, плюс все оставшиеся записи из внешней (левой) таблицы, которые не удовлетворяют условию объединения.
RIGHT JOIN — работает точно так же, как и левое объединение, только в качестве внешней таблицы будет использоваться правая.
</details>

#### А что такое Self JOIN?
<details>
<summary>Ответ</summary>
Такой вопрос тоже может прозвучать на собеседовании по SQL. Это выражение используется для того, чтобы таблица объединилась сама с собой, словно это две разные таблицы. Чтобы такое реализовать, одна из таких «таблиц» временно переименовывается.
</details>


#### Как работают подстановочные знаки?
<details>
<summary>Ответ</summary>
Это специальные символы, которые нужны для замены каких-либо знаков в запросе. Они используются вместе с оператором LIKE, с помощью которого можно отфильтровать запрашиваемые данные.

Какими бывают подстановочные знаки?
% — заменить ноль или более символов;
_ — заменить один символ.
</details>

#### Что делают псевдонимы Aliases?
<details>
<summary>Ответ</summary>
SQL-псевдонимы нужны для того, чтобы дать временное имя таблице или столбцу. Это нужно, когда в запросе есть таблицы или столбцы с неоднозначными именами. В этом случае для удобства в составлении запроса используются псевдонимы. SQL-псевдоним существует только на время запроса.
</details>

#### Какой оператор имеет больший приоритет AND или OR (если они используются совместно)?
<details>
<summary>Ответ</summary>
AND имеет больший приоритет, нежели OR
</details>

#### Что такое оконная функция? И в чем отличие от функции агрегации с группировкой?
<details>
<summary>Ответ</summary>
Оконная функция в SQL - функция, которая работает с выделенным набором строк (окном, партицией) и выполняет вычисление для этого набора строк в отдельном столбце.

При использовании агрегирующих функций предложение GROUP BY сокращает количество строк в запросе с помощью их группировки. При использовании оконных функций количество строк в запросе не уменьшается по сравнению с исходной таблицей.
</details>

#### Перечислите виды оконных функций
<details>
<summary>Ответ</summary>
Оконные функции можно подразделить на следующие группы:

Агрегатные функции;
Ранжирующие функции;
Функции смещения;
Аналитические функции.

В одной инструкции SELECT с одним предложением FROM можно использовать сразу несколько оконных функций. Давайте подробно разберем каждую группу и пройдемся по основным функциям.

_Агрегатные функции_ – это функции, которые выполняют на наборе данных арифметические вычисления и возвращают итоговое значение.

SUM – возвращает сумму значений в столбце;
COUNT — вычисляет количество значений в столбце (значения NULL не учитываются);
AVG — определяет среднее значение в столбце;
MAX — определяет максимальное значение в столбце;
MIN — определяет минимальное значение в столбце.

_Ранжирующие функции_ – это функции, которые ранжируют значение для каждой строки в окне. Их можно использовать для того, чтобы присвоить порядковый номер строке или составить рейтинг.

ROW_NUMBER – возвращает номер строки и используется для нумерации;
RANK — возвращает ранг каждой строки. В данном случае значения уже анализируются и, в случае нахождения одинаковых значений, функция возвращает одинаковый ранг с пропуском следующего значения;
DENSE_RANK — возвращает ранг каждой строки. В отличие от функции RANK, она для одинаковых значений возвращает ранг, не пропуская следующий;
NTILE – позволяет определить к какой группе относится текущая строка. Количество групп задается в скобках.

_Функции смещения_ - позволяют перемещаться и обращаться к разным строкам в окне, относительно текущей строки. Также позволяют обращаться к значениям в начале или в конце окна.

LAG – обращается к данным из предыдущей строки окна;
LEAD – обращается к данным из следующей строки.
Функции можно использовать для того, чтобы сравнивать текущее значение строки с предыдущим или следующим. Имеют три параметра: столбец, значение которого необходимо вернуть, количество строк для смещения (по умолчанию 1), значение, которое необходимо вернуть если после смещения возвращается значение NULL;
FIRST_VALUE — можно получить первое значение в окне;
LAST_VALUE — можно получить последнее значение в окне. В качестве параметра функции принимают столбец, значение которого необходимо вернуть.



_Аналитические функции_ — функции возвращают информацию о распределении данных и используются для статистического анализа.

CUME_DIST — вычисляет интегральное распределение (относительное положение) значений в окне;
PERCENT_RANK — вычисляет относительный ранг строки в окне;
PERCENTILE_CONT — вычисляет процентиль на основе постоянного распределения значения столбца. В качестве параметра принимает процентиль, который необходимо вычислить (в этой статье я рассказываю как посчитать медиану, благодаря этой функции);
PERCENTILE_DISC — вычисляет определенный процентиль для отсортированных значений в наборе данных. В качестве параметра принимает процентиль, который необходимо вычислить.

</details>

#### Что такое агрегатные и скалярные функции?
<details>
<summary>Ответ</summary>
Агрегатная функция выполняет вычисление над набором значений и возвращает одно значение. В табличной модели данных это значит, что функция берет ноль, одну или несколько строк для какой-то колонки и возвращает единственное значение. Скалярные функции принимают на вход одно значение и возвращают одно значение.

Примеры агрегатных функций:

AVG() - вычисляет среднее значение
MAX() - вычисляет элемент с максимальным значением
MIN() - ычисляет элемент с минимальным значением
SUM() - суммирует значения

Примеры скалярных функций:

LEN() - вычисляет общую длину поля
MID() - извлекает подстроки из набора строковых значений в таблице
RAND() - генерирует случайный набор чисел заданной длины
NOW() - возвращает текущую дату и время
</details>



#### Что такое представление?
<details>
<summary>Ответ</summary>
Представление (VIEW) — объект базы данных, являющийся результатом выполнения запроса к базе данных, определенного с помощью оператора SELECT, в момент обращения к представлению.

Представление в SQL - это виртуальная таблица, основанная на наборе результатов инструкции SQL. Представление содержит строки и столбцы, точно так же, как настоящая таблица. Поля в представлении - это поля из одной или нескольких реальных таблиц в базе данных.

Представления иногда называют «виртуальными таблицами». Такое название связано с тем, что представление доступно для пользователя как таблица, но само оно не содержит данных, а извлекает их из таблиц в момент обращения к нему. Если данные изменены в базовой таблице, то пользователь получит актуальные данные при обращении к представлению, использующему данную таблицу; кэширования результатов выборки из таблицы при работе представлений не производится. При этом, механизм кэширования запросов (query cache) работает на уровне запросов пользователя безотносительно к тому, обращается ли пользователь к таблицам или представлениям.

Представления могут основываться как на таблицах, так и на других представлениях, т.е. могут быть вложенными (до 32 уровней вложенности).

Преимущества использования представлений:
Дает возможность гибкой настройки прав доступа к данным за счет того, что права даются не на таблицу, а на представление. Это очень удобно в случае если пользователю нужно дать права на отдельные строки таблицы или возможность получения не самих данных, а результата каких-то действий над ними.
Позволяет разделить логику хранения данных и программного обеспечения. Можно менять структуру данных, не затрагивая программный код, нужно лишь создать представления, аналогичные таблицам, к которым раньше обращались приложения. Это очень удобно когда нет возможности изменить программный код или к одной базе данных обращаются несколько приложений с различными требованиями к структуре данных.
Удобство в использовании за счет автоматического выполнения таких действий как доступ к определенной части строк и/или столбцов, получение данных из нескольких таблиц и их преобразование с помощью различных функций.
</details>


#### Что такое CTE?
<details>
<summary>Ответ</summary>
Common Table Expression (CTE) — результаты запроса, которые можно использовать множество раз в других запросах. То есть, запросом мы достаем данные, и они помещаются в пространство памяти, аналогично временному представлению, которое физически не сохраняется в виде объектов. Далее мы работаем с получившейся конструкцией как с таблицей, используя такие конструкции как select, update, insert и delete.

</details>




#### Опишите преимущества и недостатки CTE
<details>
<summary>Ответ</summary>
CTE, или Common Table Expressions — один из видов запросов в системах управления базами данных. На русском языке они называются обобщенными табличными выражениями. Результаты табличных выражений можно временно сохранять в памяти и обращаться к ним повторно.
Преимущества CTE
Ускоряют код. При грамотном применении табличные выражения делают работу запросов быстрее, так как в памяти не приходится подолгу хранить лишние сущности — временные структуры работают только в рамках одного запроса.

Упрощают понимание. В рамках CTE происходит разбиение сложного запроса на несколько «блоков»: сначала описывается временная структура, а потом данные получают уже из нее. Получение данных оказывается последовательным и понятным.

Облегчают поддержку. В сложном запросе непросто разобраться стороннему программисту, который впервые увидел конкретный код. С помощью CTE запрос раскладывается на составляющие, поэтому его легче поддерживать, исправлять и модифицировать.

Улучшают функциональность. Рекурсивные CTE помогают легко обойти сложные структуры данных, такие как деревья. Без этого инструмента задача стала бы сложнее. Это не единственный пример, когда благодаря табличным выражениям решение задачи становится легче, но один из самых наглядных.

Имеют широкую поддержку. CTE используются во многих популярных системах, просто называются по-разному. Если вы освоите табличные выражения, например в PostgreSQL, то в будущем вам будет легче познакомиться с похожими структурами в Oracle или других СУБД.

Недостатки CTE
Не универсальны. Обобщенные табличные выражения — не универсальный инструмент, и в решении ряда задач они оказываются неоптимальными. CTE довольно ресурсоемки: они хранят в кэше временную структуру данных, к которой постоянно обращается как основной запрос, так, возможно, и само табличное выражение.

Имеют особенности оптимизации. Есть еще одна проблема. Она существует из-за оптимизатора — внутренней структуры PostgreSQL, которая занимается тем, что упрощает и оптимизирует введенные человеком запросы. Внутреннее выражение, то, что находится после ключевых слов WITH…AS, оптимизируется не так хорошо, как более простые функции. Поэтому есть риск, что CTE будет работать медленно, несмотря на то что по своей сути должно быть быстрым.

Для работы потребуются созданная база данных, на которой можно тренироваться, и установленная СУБД, например PostgreSQL. Большинство СУБД, включая PostgreSQL, бесплатные, находятся в открытом доступе и хорошо задокументированы.


</details>



#### Опишите отличия CTE и VIEW
<details>
<summary>Ответ</summary>

Итак, что лучше и когда?
СТЕ обычно лучше, когда:

SQL Server может хорошо оценить, сколько строк будет возвращено из него, и каково будет содержимое этих строк, или

Когда то, что возвращает СТЕ, не оказывает фактического влияния на поведение остального запроса, или

Когда вы не уверены, какая часть данных СТЕ будет фактически необходима для остального запроса (поскольку SQL Server может определять, какие части выполнять, а какие просто проигнорировать).


Временные таблицы обычно лучше, когда:

Вы должны обращаться к выводу много раз, или

Когда вам необходимо передавать данные между хранимыми процедурами, или

Когда вам нужно разбить запрос на этапы, чтобы изолировать непредсказуемые элементы, которые оказывают сильное влияние на остальную часть запроса.
</details>

#### Что такое ETL  и ELT?
<details>
<summary>Ответ</summary>
ETL и ELT — два разных способа загрузки данных в хранилище.
</details>

#### Что такое ETL 
<details>
<summary>Ответ</summary>

ETL (Extract, Transform, Load) сначала извлекают данные из пула источников данных. Данные хранятся во временной промежуточной базе данных. Затем выполняются операции преобразования, чтобы структурировать и преобразовать данные в подходящую форму для целевой системы хранилища данных. Затем структурированные данные загружаются в хранилище и готовы к анализу.

</details>


#### Что такое ELT 
<details>
<summary>Ответ</summary>
В случае ELT (Extract, Load, Transform) данные сразу же загружаются после извлечения из исходных пулов данных. Промежуточная база данных отсутствует, что означает, что данные немедленно загружаются в единый централизованный репозиторий.
Данные преобразуются в системе хранилища данных для использования с инструментами бизнес-аналитики и аналитики.
</details>


