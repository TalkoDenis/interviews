Ниже представлен ряд вопросов по SQL.

Это те вопросы, которые интервьюеры часто задают на собеседованиях. Я старался подобрать как можно больше вопросов, которые задают аналитикам данных.
После каждого вопроса дан ответ. Но для самопроверки попробуйте сперва ответить сами, не подглядывая в шпаргалку.

![Интервью SQL](https://github.com/TalkoDenis/interviews/blob/main/SQL/Theory/%D0%93%D0%BE%D0%BC%D0%B5%D1%80.jpg)


#### Что такое SQL?
<details>
<summary>Ответ</summary>

_SQL (Structured Query Language)_ - язык структурированных запросов. Это стандартный язык для СУБД. Он особенно полезен при обработке организованных данных, состоящих из сущностей (переменных) и отношений между различными сущностями данных.
</details>

#### Что такое таблицы и поля?
<details>
<summary>Ответ</summary>

_Таблица_ - это организованный набор данных, хранящихся в виде строк и столбцов. Столбцы могут быть классифицированы как вертикальные поля, а строки - как горизонтальные.
_Поля_ - это колонки в таблице, предназначенные для хранения информации.
</details>

#### Что такое база данных?
<details>
<summary>Ответ</summary>
Можно дать несколько разных определений. Ниже представлены те, которые я считаю наиболее удачными.

_База данных_ - это совокупность данных, хранящихся и извлекаемых в цифровом виде из удалённой или локальной компьютерной системы.

_База данных_ - это упорядоченный набор структурированной информации или данных, которые обычно хранятся в электронном виде в компьютерной системе. База данных обычно управляется системой управления базами данных (СУБД).

_База данных_ - это совокупность данных, хранимых в соответствии со схемой данных, манипулирование которыми выполняют в соответствии с правилами средств моделирования данных
</details>

#### Что такое СУБД?
<details>
<summary>Ответ</summary>

_СУБД_ - Система Управления Базами Данных. СУБД - это системное программное обеспечение, ответственное за создание, поиск, обновление и управление базы данных. СУБД гарантирует, наши данные организованы и легкодоступны, выступая в качестве интерфейса между базой данных и её конечными пользователями.
</details>

#### Что такое РСУБД? В чём заключается её отличие от СУБД?
<details>
<summary>Ответ</summary>

_РСУБД_ - Реляционная Система Управления Базами Данных. Ключевое отличие по сравнению с СУБД в том, что РСУБД хранит данные в виде набора таблиц, и между общими полями этих таблиц могут существовать отношения. Большинство современных систем управления базами данных, таких как MySQL, Microsoft SQL Server, Oracle, IBM DB2 и Amazon Redshift, основаны на РСУБД.
</details>

#### Что такое нормализация?
<details>
<summary>Ответ</summary>

_Нормализация_ — это процесс организации данных в базе данных, включающий создание таблиц и установление отношений между ними в соответствии с правилами, которые обеспечивают защиту данных и делают базу данных более гибкой, устраняя избыточность и несогласованные зависимости.
</details>

#### Что такое денормализация?
<details>
<summary>Ответ</summary>

_Денормализация_ - это процесс обратный нормализации. При денормализации нормализованная схема преобразуется в схему, содержащую избыточную информацию. Производительность повышается за счет использования избыточности и обеспечения согласованности избыточных данных. Причиной выполнения денормализации являются накладные расходы, возникающие в процессоре запросов из-за чрезмерно нормализованной структуры.
</details>

#### Из каких подмножеств состоит SQL?
<details>
<summary>Ответ</summary>

_DDL (Data Definition Language, язык описания данных)_ — позволяет выполнять различные операции с базой данных, такие как CREATE (создание), ALTER (изменение) и DROP (удаление объектов).
_DML (Data Manipulation Language, язык управления данными)_ — позволяет получать доступ к данным и манипулировать ими, например, вставлять, обновлять, удалять и извлекать данные из базы данных.
_DCL (Data Control Language, язык контролирования данных)_ — позволяет контролировать доступ к базе данных. Пример — GRANT (предоставить права), REVOKE (отозвать права).
</details>

#### Расскажите про нормальные формы. Какие они бывают и чем отличаются?
<details>
<summary>Ответ</summary>

_Нормальная форма_ — требование, предъявляемое к структуре таблиц в теории реляционных баз данных для устранения из базы избыточных функциональных зависимостей между атрибутами (полями таблиц).
Всего существует шесть нормальных форм. Самая основная и наиболее часто используемая - третья нормальная форма (3НФ), по этой причине, тут будет дано определение только первых трёх нормальных форм. Для аналитика данных этого более чем достаточно.

_Первая нормальная форма_ - оношение находится в 1НФ, если все его атрибуты[^1] являются простыми, все используемые домены[^2] должны содержать только скалярные значения. Не должно быть повторений строк в таблице.

_Вторая нормальная форма_ - отношение находится во 2НФ, если оно находится в 1НФ и каждый не ключевой атрибут неприводимо зависит от первичного Ключа. Неприводимость означает, что в составе потенциального ключа отсутствует меньшее подмножество атрибутов, от которого можно также вывести данную функциональную зависимость.

_Третья нормальная форма_ - отношение находится в 3НФ, когда находится во 2НФ и каждый не ключевой атрибут нетранзитивно зависит от первичного ключа. Проще говоря, требуется выносить все не ключевые поля, содержимое которых может относиться к нескольким записям таблицы в отдельные таблицы.

_Нормальная форма Бойса-Кодда (НФБК)_ - это частная форма третьей нормальной формы.

Определение 3НФ не подходит для следующих отношений:
1) отношение имеет два или более потенциальных ключа;
2) два и более потенциальных ключа являются составными;
3) ключи пересекаются, т.е. имеют хотя бы один общий атрибут.

Для отношений, имеющих один потенциальный ключ (первичный), НФБК является 3НФ. Отношение находится в НФБК, когда каждая нетривиальная и неприводимая слева функциональная зависимость обладает потенциальным ключом в качестве детерминанта.

[^1]: Атрибут — свойство некоторой сущности. Часто называется полем таблицы.

[^2]: Домен атрибута — множество допустимых значений, которые может принимать атрибут.
</details>

#### Что такое первичный ключ?
<details>
<summary>Ответ</summary>

_Первичный ключ (Primary Key)_ предназначен для однозначной идентификации каждой записи в таблице и является строго уникальным (unique): две записи таблицы не могут иметь одинаковые значения первичного ключа. Нулевые значения (NULL) в качестве первичного ключа не допускаются. Если в качестве первичного ключа используется несколько полей, их называют составным ключом.
</details>

#### Когда используется первичный ключ?
<details>
<summary>Ответ</summary>
Первичный ключ используется в качестве основного ключа и может быть использован для связи с дочерней таблицей, содержащей внешний ключ.
</details>

#### Что такое внешний ключ?
<details>
<summary>Ответ</summary>

_Внешний ключ (Foreign Key)_ является атрибутом ограничения и обеспечивает связь двух таблиц. По сути, это поле или несколько полей, которые ссылаются на первичный ключ в родительской таблице.
</details>

#### Чем NULL отличается от 0?
<details>
<summary>Ответ</summary>
0 - это число.
NULL - это не число, а также NULL не является значением пустой строки. NULL используется для указания того, что данные отсутствуют, неизвестны, неприменимы. NULL не равен ничему, даже другому NULL.
</details>

#### Перечислите различные типы связей.
<details>
<summary>Ответ</summary>

_Один-к-одному (One-to-One)_ - этот тип может быть определён как отношение между двумя таблицами, где каждая запись в одной таблице связана максимум с одной записью в другой таблице.
_Один-ко-многим и Многие-к-одному (One-to-Many & Many-to-One)_ - это наиболее часто используемое отношение, когда запись в таблице связана с несколькими записями в другой таблице.
_Многие-ко-многим (Many-to-Many)_ - этот тип используется в случаях, когда для определения отношения требуется несколько экземпляров с обеих сторон.

На приведённой ниже схеме показаны примеры свезей Один-ко-многим / Многие-к-одному, где "1" означает "один", и "*" означает "много".

![Интервью SQL](https://github.com/TalkoDenis/interviews/blob/main/SQL/Theory/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D1%8B%20%D1%81%D0%B2%D1%8F%D0%B7%D0%B5%D0%B9.png)

</details>


#### Что такое схема "Звезда" и "Снежинка"? Опишите их сходства и различия.
<details>
<summary>Ответ</summary>
Схемы «звезда» и «снежинка» - это два способа структурировать хранилище данных.

_Схема «звезда» (star schema)_ - специальная организация реляционных таблиц, удобная для хранения многомерных показателей. Лежит в основе реляционного OLAP.

Схема типа «звезда» имеет централизованное хранилище данных, которое хранится в таблице фактов (fact table). Схема разбивает таблицу фактов на ряд денормализованных таблиц измерений (dimension table). Таблица фактов содержит агрегированные данные, которые будут использоваться для составления отчетов, а таблица измерений описывает хранимые данные.

Денормализованные проекты менее сложны, потому что данные сгруппированы. Таблица фактов использует только одну ссылку для присоединения к каждой таблице измерений. Более простая конструкция звездообразной схемы значительно упрощает написание сложных запросов.

Модель данных состоит из двух типов таблиц: одной таблицы фактов  — центр «звезды» — и нескольких таблиц измерений по числу измерений в модели данных — лучи «звезды».

Пример схемы "звёзда":
Таблица фактов содержит одну или несколько колонок типа DECIMAL, дающих числовую характеристику какому-то аспекту предметной области (например, объём продаж для торговой компании или сумма платежей для банка), и несколько целочисленных колонок-ключей для доступа к таблицам измерений. В таблицы фактов данные должны оперативно записываться в случае изменений.

Таблицы измерений расшифровывают ключи, на которые ссылается таблица фактов; например, таблица «products» измерения «товары» базы данных торговой компании может содержать сведения о названии товара, его производителе, типе товара. За счёт использования специальной структуры таблицы измерений реализуется иерархия измерений, в том числе ветвящаяся.

Обычно данные в таблицах-измерениях денормализованы: ценой несколько неэффективного использования дискового пространства удается уменьшить число участвующих в операции соединения таблиц, что обычно приводит к сильному уменьшению времени выполнения запроса. Иногда, тем не менее, требуется произвести нормализацию таблиц-измерений. Такая схема носит название «снежинка».

SQL-запрос к схеме «звезда» обычно содержит в себе:

- одно или несколько соединений таблицы фактов с таблицами измерений;
- несколько фильтров (оператор WHERE), применяемых к таблице фактов или таблицам измерений;
- группировку и агрегирование по требуемым элементам иерархии измерений (dimension elements).

Схема типа «снежинка» (snowflake schema) отличается тем, что использует нормализованные данные. Нормализация означает эффективную организацию данных так, чтобы все зависимости данных были определены, и каждая таблица содержала минимум избыточности. Таким образом, отдельные таблицы измерений разветвляются на отдельные таблицы измерений.

Схема «снежинки» использует меньше дискового пространства и лучше сохраняет целостность данных. Основным недостатком является сложность запросов, необходимых для доступа к данным — каждый запрос должен пройти несколько соединений таблиц, чтобы получить соответствующие данные.

Схема снежинки получила своё название за свою форму, в виде которой отображается логическая схема таблиц в многомерной базе данных. Так же как и в схеме звезды, схема снежинки представлена централизованной таблицей фактов, соединенной с таблицами измерений. Отличием является то, что здесь таблицы измерений нормализованы с рядом других связанных измерительных таблиц, — в то время как в схеме звезды таблицы измерений полностью денормализованы, с каждым измерением представленным в виде единой таблицы, без соединений на связанные таблицы в схеме снежинки. Чем больше степень нормализации таблиц измерений, тем сложнее выглядит структура схемы снежинки. Создаваемый «эффект снежинки» затрагивает только таблицы измерений, и не применим к таблицам фактов.

Схема снежинки, также как и схема звезды, наиболее часто встречается в таких хранилищах данных, для которых скорость получения данных более важна, чем эффективность манипуляции ими. Следовательно, таблицы должны быть нормализованы в малой степени, и зачастую разрабатываются с применением не выше третьего уровня нормализации.

Решение в сторону использования схемы звезды или же схемы снежинки, обуславливается относительной мощностью платформы БД, и инструментария для реализации запросов. Схема звезды подходит окружению, в котором инструментарий реализации запросов предоставляет пользователям широкий доступ к структуре таблиц, а также в окружениях, где большинство запросов просты по своей природе. Схема снежинки более подходит для случаев применения более сложного инструментария для реализации запросов, который в большей степени изолирует пользователей от детальной структуры таблиц, а также для среды с множеством запросов сложной структуры.


Для простоты понимания можно считать, что "снежинка" состоит из нескольких "звёзд".

Примеры схем звезда и снежинка.

![image](https://github.com/TalkoDenis/interviews/blob/main/SQL/Theory/%D0%97%D0%B2%D0%B5%D0%B7%D0%B4%D0%B0%20%D0%B8%20%D1%81%D0%BD%D0%B5%D0%B6%D0%B8%D0%BD%D0%BA%D0%B0%202.gif)


![image](https://github.com/TalkoDenis/interviews/blob/main/SQL/Theory/%D0%97%D0%B2%D0%B5%D0%B7%D0%B4%D0%B0%20%D0%B8%20%D1%81%D0%BD%D0%B5%D0%B6%D0%B8%D0%BD%D0%BA%D0%B0.gif)

</details>

#### Что такое таблица фактов и таблица измерений?
<details>
<summary>Ответ</summary>

_Таблица фактов (fact table)_ — это таблица, записи которой являются неизменяемыми "фактами", такими как журналы служб и сведения об измерениях. Записи постепенно добавляются в таблицу потоковой передачей или большими блоками. Записи остаются там до тех пор, пока они не будут удалены из-за затрат или из-за потери их стоимости. В противном случае записи никогда не обновляются. Таблица фактов — является основной таблицей хранилища данных. 

Таблица фактов, как правило, содержит уникальный составной ключ, объединяющий первичные ключи таблиц измерений. Чаще всего это целочисленные значения либо значения типа «дата/время» в целочисленном формате — ведь таблица фактов может содержать сотни тысяч или даже миллионы записей, и хранить в ней повторяющиеся текстовые описания, как правило, невыгодно — лучше поместить их в меньшие по объёму таблицы измерений. Помимо этого, таблица фактов содержит одно или несколько числовых полей, на основании которых в дальнейшем будут получены агрегатные данные.

В таблице фактов нет никаких сведений о том, как группировать записи при вычислении агрегатных данных. Например, в ней есть идентификаторы продуктов или клиентов, но отсутствует информация о том, к какой категории относится данный продукт или в каком городе находится данный клиент. Эти сведения, в дальнейшем используемые для построения иерархий, содержатся в таблицах измерений.

_Таблица измерений (dimension table)_ - таблица в структуре многомерной базы данных, которая содержит атрибуты событий, сохраненных в таблице фактов. Атрибуты представляют собой текстовые или иные описания, логически объединенные в одно целое. Например, имя покупателя может являться атрибутом в таблице измерений покупателей, а наименование товара - в таблице измерений товаров. В то время как сумма транзакции является величиной аддитивной, и её значение должно храниться в таблице фактов.

Таблица фактов связана с таблицами измерений с помощью внешнего ключа.

С течением времени значения атрибутов строки в таблице измерений могут измениться. Например, юридический адрес компании или отдел компании, в котором работает сотрудник. Для отслеживания и обработки в таком случае используют медленно меняющиеся измерения. Есть несколько типов обработки таких изменений:
- перезаписать старые значения.
- добавить новую строку, содержащую новые значения, сохраняя бизнес-ключ для различия строк.
- добавить новый атрибут в существующую строку.
</details>

#### Какая разница между UNION и UNION ALL?
<details>
<summary>Ответ</summary>
Оба эти выражения используются, чтобы объединить результаты нескольких независимых друг от друга запросов. Разница заключается в том, что, если в результатах запросов есть одинаковые строки, то UNION удалит дубликаты, оставив только одну из таких строк. UNION ALL просто объединит результаты запросов, не обращая внимания на дубликаты.

Перед применением любого из приведенных выше операторов, должны быть выполнены следующие условия:

1. Каждый оператор SELECT в предложении должен иметь одинаковое количество столбцов;
2. Столбцы также должны иметь аналогичные типы данных;
3. Столбцы в каждой инструкции SELECT обязательно должны иметь одинаковый порядок.
</details>

#### Зачем нужны операторы EXCEPT и INTERSECT?
<details>
<summary>Ответ</summary>

_EXCEPT_ - отвечает за разницу множеств. В результат попадают уникальные строки верхнего набора, которые отсутствуют в нижнем наборе.
_INTERSECT_ - отвечает за пересечение строк из обоих подзапросов.
  
Перед применением любого из приведенных выше операторов, должны быть выполнены следующие условия:

1. Каждый оператор SELECT в предложении должен иметь одинаковое количество столбцов;
2. Столбцы также должны иметь аналогичные типы данных;
3. Столбцы в каждой инструкции SELECT обязательно должны иметь одинаковый порядок.
</details>

#### Какая разница между выражениями WHERE и HAVING?
<details>
<summary>Ответ</summary>
Выражения WHERE и HAVING используются для фильтрации результата запроса и ожидают после себя некоторое условие, по которому нужно отфильтровать данные.
  
_WHERE_ работает само по себе и фильтрует данные каждой строки результата по отдельности. 
_HAVING_ имеет смысл только в сочетании с выражением GROUP BY и фильтрует уже сгруппированные значения.
</details>

#### Для чего используется ключевое слово ORDER BY?
<details>
<summary>Ответ</summary>
Для сортировки данных в порядке возрастания (ASC) или убывания (DESC).
</details>

#### Назовите четыре основных типа соединения в SQL
<details>
<summary>Ответ</summary>
Чтобы объединить две таблицы в одну, следует использовать оператор JOIN.
  
_INNER JOIN_ - получение записей с одинаковыми значениями в обеих таблицах, т.е. получение пересечения таблиц.
_FULL OUTER JOIN_ - объединяет записи из обеих таблиц (если условие объединения равно true) и дополняет их всеми записями из обеих таблиц, которые не имеют совпадений. Для записей, которые не имеют совпадений из другой таблицы, недостающее поле будет иметь значение NULL.
_LEFT JOIN_ - возвращает все записи, удовлетворяющие условию объединения, плюс все оставшиеся записи из внешней (левой) таблицы, которые не удовлетворяют условию объединения.
_RIGHT JOIN_ - работает точно так же, как и левое объединение, только в качестве внешней таблицы будет использоваться правая.
</details>

#### Что такое Self JOIN?
<details>
<summary>Ответ</summary>
Это выражение используется для того, чтобы таблица объединилась сама с собой, словно это две разные таблицы. Чтобы такое реализовать, одна из таких «таблиц» временно переименовывается.
</details>

#### Что такое подстановочные знаки и какие их виды бывают?
<details>
<summary>Ответ</summary>

_Подстановочные знаки_ - это специальные символы, которые нужны для замены каких-либо знаков в запросе. Они используются вместе с оператором LIKE, с помощью которого можно отфильтровать запрашиваемые данные.

Подстановочные знаки бывают двух видов:

% — заменить ноль или более символов;
_ — заменить один символ.
</details>

#### Что делают псевдонимы Aliases (AS)?
<details>
<summary>Ответ</summary>
Псевдонимы нужны для того, чтобы дать временное имя таблице или столбцу. Это нужно, когда в запросе есть таблицы или столбцы с неоднозначными именами. В этом случае для удобства в составлении запроса используются псевдонимы. Псевдоним существует только на время запроса. Пишется псевдоним как AS.
</details>

#### Какой оператор AND или OR имеет больший приоритет (если они используются совместно)?
<details>
<summary>Ответ</summary>
AND имеет больший приоритет, чем OR.
</details>

#### Что такое оконная функция? И в чем отличие от функции агрегации с группировкой?
<details>
<summary>Ответ</summary>
Оконная функция в SQL - функция, которая работает с выделенным набором строк (окном) и выполняет вычисление для этого набора строк в отдельном столбце.

При использовании агрегирующих функций предложение GROUP BY сокращает количество строк в запросе с помощью их группировки. При использовании оконных функций количество строк в запросе не уменьшается по сравнению с исходной таблицей.
</details>

#### Перечислите виды оконных функций
<details>
<summary>Ответ</summary>
Оконные функции можно подразделить на следующие группы:

_Агрегатные функции_;
_Ранжирующие функции_;
_Функции смещения_;
_Аналитические функции_.

В одной инструкции SELECT с одним предложением FROM можно использовать сразу несколько оконных функций.

_Агрегатные функции_ – это функции, которые выполняют на наборе данных арифметические вычисления и возвращают итоговое значение.

_SUM()_ - возвращает сумму значений в столбце;
_COUNT()_ - вычисляет количество значений в столбце (значения NULL не учитываются);
_AVG()_ - определяет среднее значение в столбце;
_MAX()_ - определяет максимальное значение в столбце;
_MIN()_ - определяет минимальное значение в столбце.

_Ранжирующие функции_ – ранжируют значение для каждой строки в окне. Их можно использовать для того, чтобы присвоить порядковый номер строке или составить рейтинг.

_ROW_NUMBER()_ – возвращает номер строки и используется для нумерации;
_RANK()_ — возвращает ранг каждой строки. В данном случае значения уже анализируются и, в случае нахождения одинаковых значений, функция возвращает одинаковый ранг с пропуском следующего значения;
_DENSE_RANK()_ — возвращает ранг каждой строки. В отличие от функции RANK, она для одинаковых значений возвращает ранг, не пропуская следующий;
_NTILE()_ – позволяет определить к какой группе относится текущая строка. Количество групп задается в скобках.

_Функции смещения_ - позволяют перемещаться и обращаться к разным строкам в окне, относительно текущей строки. Также позволяют обращаться к значениям в начале или в конце окна.

_LAG()_ – обращается к данным из предыдущей строки окна;
_LEAD()_ – обращается к данным из следующей строки.

Функции можно использовать для того, чтобы сравнивать текущее значение строки с предыдущим или следующим. Имеют три параметра: столбец, значение которого необходимо вернуть, количество строк для смещения (по умолчанию 1), значение, которое необходимо вернуть если после смещения возвращается значение NULL;

_FIRST_VALUE()_ - можно получить первое значение в окне;
_LAST_VALUE()_ - можно получить последнее значение в окне. В качестве параметра функции принимают столбец, значение которого необходимо вернуть.

_Аналитические функции_ - возвращают информацию о распределении данных и используются для статистического анализа.

_CUME_DIST()_ - вычисляет интегральное распределение (относительное положение) значений в окне;
_PERCENT_RANK()_ - вычисляет относительный ранг строки в окне;
_PERCENTILE_CONT()_ - вычисляет процентиль на основе постоянного распределения значения столбца. В качестве параметра принимает процентиль, который необходимо вычислить (в этой статье я рассказываю как посчитать медиану, благодаря этой функции);
_PERCENTILE_DISC()_ - вычисляет определенный процентиль для отсортированных значений в наборе данных. В качестве параметра принимает процентиль, который необходимо вычислить.
</details>

#### Что такое агрегатные и скалярные функции?
<details>
<summary>Ответ</summary>

_Агрегатная функция_ выполняет вычисление над набором значений и возвращает одно значение. В табличной модели данных это значит, что функция берет ноль, одну или несколько строк для какой-то колонки и возвращает единственное значение. Скалярные функции принимают на вход одно значение и возвращают одно значение.

Примеры агрегатных функций:

_SUM()_ - возвращает сумму значений в столбце;
_COUNT()_ - вычисляет количество значений в столбце (значения NULL не учитываются);
_AVG()_ - определяет среднее значение в столбце;
_MAX()_ - определяет максимальное значение в столбце;
_MIN()_ - определяет минимальное значение в столбце.

Примеры скалярных функций:

_LEN()_ - вычисляет общую длину поля;
_MID()_ - извлекает подстроки из набора строковых значений в таблице;
_RAND()_ - генерирует случайный набор чисел заданной длины;
_NOW()_ - возвращает текущую дату и время.
</details>

#### В чём отличие между COUNT(*), COUNT(столбец/выражение) и COUNT(DISTINCT столбец/выражение)?
<details>
<summary>Ответ</summary>

_COUNT(*)_ - возвращает количество строк полученных оператором «SELECT … WHERE …». В случае отсутствии WHERE, количество всех записей таблицы.
_COUNT(столбец/выражение)_ - возвращает количество значений (не равных NULL), в указанном столбце/выражении
_COUNT(DISTINCT столбец/выражение)_ - возвращает количество _уникальных значений_, не равных NULL в указанном столбце/выражении
</details>

#### Что такое представление (VIEW)?
<details>
<summary>Ответ</summary>
_Представление (VIEW)_ - объект базы данных, являющийся результатом выполнения запроса к базе данных, определенного с помощью оператора SELECT, в момент обращения к представлению.

Представление в SQL - это виртуальная таблица, основанная на наборе результатов инструкции SQL. Представление содержит строки и столбцы, точно так же, как настоящая таблица. Поля в представлении - это поля из одной или нескольких реальных таблиц в базе данных.

Представления иногда называют «виртуальными таблицами». Такое название связано с тем, что представление доступно для пользователя как таблица, но само оно не содержит данных, а извлекает их из таблиц в момент обращения к нему. Если данные изменены в базовой таблице, то пользователь получит актуальные данные при обращении к представлению, использующему данную таблицу. Представления могут основываться как на таблицах, так и на других представлениях, т.е. могут быть вложенными (до 32 уровней вложенности).
</details>

#### Что такое подзапрос?
<details>
<summary>Ответ</summary>

_Подзапрос_ - это SELECT-запрос, вложенный в другой запрос или подзапрос. Другими словами подзапрос - это внутренний запрос. Внешний запрос - это оператор, который содержит подзапрос.

Подзапросами пользуются, когда нужно использовать результат выполнения одного запроса в следующем запросе. Синтаксически подзапрос - это обычный запрос, обернутый в круглые скобки. Подзапрос может быть вложен в любой другой оператор. Можно вкладывать подзапросы в подзапросы. Вложенные запросы можно использовать практически во всех частях внешнего запроса: везде, где разрешено использовать значения.

Подзапросы могут возвращать как скалярные значения, так и табличные значения. От типа возвращаемого значения зависит, с какими операциями имеет смысл использовать подзапрос.

_Скалярное значение_ - это когда возвращается одно значение. Обычно это число или строка. Со скалярными значениями можно использовать операторы сравнения (<, >, =), можно передавать как аргумент функции или как значение колонки в операторе SELECT.

_Табличное значение_ - когда возвращается несколько строк. Заранее неизвестно сколько: ноль, одна или больше. С табличными значениями используют операции IN, NOT IN, ANY, ALL, EXISTS, NOT EXISTS. Все эти операции проверяют вхождение строк внешнего запроса в табличное значение, возвращаемое подзапросом. Табличное значение можно использовать в разделе FROM как таблицу-источник.
</details>

#### Что такое CTE?
<details>
<summary>Ответ</summary>
  
_Common Table Expression (CTE) (Обобщённые табличные выражения)_ - результат запроса, который можно использовать множество раз в других запросах. Говоря проще: запросом мы достаем данные, и они помещаются в пространство памяти, аналогично временному представлению, которое физически не сохраняется в виде объектов. Далее можно работать с получившейся конструкцией как с таблицей.
</details>

#### Опишите преимущества и недостатки CTE
<details>
<summary>Ответ</summary>

_CTE_ - один из видов запросов в системах управления базами данных. На русском языке они называются обобщёнными табличными выражениями. Результаты табличных выражений можно временно сохранять в памяти и обращаться к ним повторно.
  
_Преимущества CTE:_

1) Ускоряют код. При грамотном применении табличные выражения делают работу запросов быстрее, так как в памяти не приходится подолгу хранить лишние сущности - временные структуры работают только в рамках одного запроса.

2) Упрощают понимание. В рамках CTE происходит разбиение сложного запроса на несколько «блоков»: сначала описывается временная структура, а потом данные получают уже из нее. Получение данных оказывается последовательным и понятным.

3) Облегчают поддержку. В сложном запросе непросто разобраться стороннему человеку, который впервые увидел конкретный код. С помощью CTE запрос раскладывается на составляющие, поэтому его легче поддерживать, исправлять и модифицировать.

4) Улучшают функциональность.

_Недостатки CTE_

1) Не универсальны. Обобщенные табличные выражения — не универсальный инструмент, и в решении ряда задач они оказываются неоптимальными.

2) Ресурсоёмки. CTE хранят в кэше временную структуру данных, к которой постоянно обращается как основной запрос, так, возможно, и само табличное выражение.

3) Имеют особенности оптимизации. Проблема существует из-за оптимизатора - внутренней структуры PostgreSQL, которая занимается тем, что упрощает и оптимизирует введенные человеком запросы. Внутреннее выражение, то, что находится после ключевых слов WITH…AS, оптимизируется не так хорошо, как более простые функции. Поэтому есть риск, что CTE будет работать медленно, несмотря на то что по своей сути должно быть быстрым.
</details>

#### Опишите отличия CTE и VIEW
<details>
<summary>Ответ</summary>

Итак, что лучше и когда?
СТЕ обычно лучше, когда:

SQL Server может хорошо оценить, сколько строк будет возвращено из него, и каково будет содержимое этих строк, или

Когда то, что возвращает СТЕ, не оказывает фактического влияния на поведение остального запроса, или

Когда вы не уверены, какая часть данных СТЕ будет фактически необходима для остального запроса (поскольку SQL Server может определять, какие части выполнять, а какие просто проигнорировать).


Временные таблицы обычно лучше, когда:

Вы должны обращаться к выводу много раз, или

Когда вам необходимо передавать данные между хранимыми процедурами, или

Когда вам нужно разбить запрос на этапы, чтобы изолировать непредсказуемые элементы, которые оказывают сильное влияние на остальную часть запроса.
</details>

#### Что такое ETL  и ELT?
<details>
<summary>Ответ</summary>
ETL и ELT — два разных способа загрузки данных в хранилище.
</details>

#### Что такое ETL 
<details>
<summary>Ответ</summary>

ETL (Extract, Transform, Load) сначала извлекают данные из пула источников данных. Данные хранятся во временной промежуточной базе данных. Затем выполняются операции преобразования, чтобы структурировать и преобразовать данные в подходящую форму для целевой системы хранилища данных. Затем структурированные данные загружаются в хранилище и готовы к анализу.

</details>


#### Что такое ELT 
<details>
<summary>Ответ</summary>
В случае ELT (Extract, Load, Transform) данные сразу же загружаются после извлечения из исходных пулов данных. Промежуточная база данных отсутствует, что означает, что данные немедленно загружаются в единый централизованный репозиторий.
Данные преобразуются в системе хранилища данных для использования с инструментами бизнес-аналитики и аналитики.
</details>








#### Для чего используется ключевое слово DISTINCT?
<details>
<summary>Ответ</summary>
В столбце с данными могут содержаться дублирующие значения. Чтобы вывести уникальные значения поля или полей (т.е. уникальные строки), нужно поставить оператор DISTINCT у требуемого поля в блоке SELECT.
</details>





#### Что такое LIMIT и для чего он используется?
<details>
<summary>Ответ</summary>
Оператор LIMIT используется, чтобы ограничить запрос и вывести только топ N результатов. Оператору передаётся либо один параметр N , если нужно извлечь N строк с начала таблицы с данными, либо два параметра - первый устанавливает смещение от первой строки, то есть сколько строк нужно пропустить, а второй указывает на количество извлекаемых строк.
</details>



#### Напишите порядок использования операторов в SQL-запросе.
<details>
<summary>Ответ</summary>
SQL-запрос имеет следующую структуру:

SELECT -- перечисление полей результирующей таблицы

FROM -- источника данных

WHERE -- фильтрация данных

JOIN -- комбинация с подходящими по условию данными из других таблиц

GROUP BY -- группировка (агрегирование) данных

HAVING -- фильтрация агрегированных данных (при использовании GROUP BY)

ORDER BY -- сортировка результирующей таблицы

LIMIT -- ограничение на кол-во строк результирующей таблицы

</details>


#### Напишите порядок выполнения SQL-запроса.
<details>
<summary>Ответ</summary>
Выше был описан порядок использования операторов в SQL-запросе. Но при этом, при выполнении скрипта, он работает в другом порядке:
  
FROM -- выбор источника данных

JOIN -- комбинация с подходящими по условию данными из других таблиц

WHERE -- фильтрация данных

GROUP BY -- группировка (агрегирование) данных

HAVING -- фильтрация агрегированных данных (при использовании GROUP BY)

SELECT -- возврат результирующего датасета

ORDER BY -- сортировка результирующей таблицы

LIMIT -- ограничение на кол-во строк результирующей таблицы

</details>


#### Расскажите про оператор CASE.
<details>
<summary>Ответ</summary>
Оператор CASE позволяет осуществить проверку условий и возвратить в зависимости от выполнения того или иного условия тот или иной результат.

Оператор имеет следующую конструкцию:
CASE
  WHEN условие_1 THEN возвращаемое_значение_1
  …
  WHEN условие_N THEN возвращаемое_значение_N
  ELSE возвращаемое_значение
END


WHEN-условия проверяются последовательно, сверху-вниз. При достижении первого удовлетворяющего условия дальнейшая проверка прерывается и возвращается значение, указанное после слова THEN, относящегося к данному блоку WHEN. Если ни одно из WHEN-условий не выполняется, то возвращается значение, указанное после слова ELSE. Если ELSE-блок не указан и не выполняется ни одно WHEN-условие, то возвращается NULL.

</details>


#### Для чего используется оператор EXISTS?
<details>
<summary>Ответ</summary>

_EXISTS_ позволяет проверить, возвращает ли подзапрос какое-либо значение. Оператор возвращает true, если подзапрос возвращает одну или несколько записей. Как правило, этот оператор используется для индикации того, что какая-либо строка удовлетворяет условию. Фактически EXISTS не возвращает строки, а лишь указывает, что в БД есть как минимум одна строка, которая соответствует данному запросу. Поскольку возвращения набора строк не происходит, то подзапросы с подобным оператором выполняются довольно быстро.

Применение оператора имеет следующий формальный синтаксис:

```WHERE (NOT) EXISTS (подзапрос)```

Стоит отметить, что для получения подобного результата можно использовать и опеатор IN, но поскольку при применении EXISTS не происходит выборка строк, то его использование более оптимально и эффективно, чем использование оператора IN.

</details>


#### Для чего используется оператор IN?
<details>
<summary>Ответ</summary>

_IN_ является одним из наиболее полезных операторов для фильтрации данных в SQL. Этот оператор позволяет выбрать строки из таблицы, которые содержат одно или несколько значений, указанных в списке.

Синтаксис оператора IN выглядит следующим образом:

```
SELECT column1, column2, ...
FROM table_name
WHERE column_name IN (value1, value2, ...)
```

</details>

#### Для чего используются операторы ANY и ALL?
<details>
<summary>Ответ</summary>

Операторы ANY и ALL используются с предложением WHERE или HAVING.
Оператор ANY возвращает true, если какое-либо из значений подзапроса удовлетворяет условию.
Оператор ALL возвращает true, если все значения подзапроса удовлетворяют условию.
Синтаксис ANY
SELECT column_name(s)
FROM table_name
WHERE column_name operator ANY
(SELECT column_name FROM table_name WHERE condition);
Синтаксис ALL
SELECT column_name(s)
FROM table_name
where="" "">column_name operator ALL
(SELECT column_name FROM table_name WHERE condition);



Примеры SQL ANY
Оператор ANY возвращает TRUE, если какое-либо из значений подзапроса удовлетворяет условию.
Следующий оператор SQL возвращает TRUE и перечисляет названия продуктов, если он находит какие-либо записи в таблице OrderDetails, что количество = 10:
Пример
SELECT ProductName
FROM Products
WHERE ProductID = ANY (SELECT ProductID FROM OrderDetails WHERE Quantity = 10);
Попробуйте сами »
Следующий оператор SQL возвращает TRUE и перечисляет названия продуктов, если он находит какие-либо записи в таблице OrderDetails, что количество > 99:
Пример
SELECT ProductName
FROM Products
WHERE ProductID = ANY (SELECT ProductID FROM OrderDetails WHERE Quantity > 99);
Попробуйте сами »
________________________________________
Пример SQL ALL
Оператор ALL возвращает TRUE, если все значения подзапроса удовлетворяют условию.
Следующая инструкция SQL возвращает TRUE и перечисляет названия продуктов, если все записи в таблице OrderDetails имеют значение quantity = 10 ( таким образом, этот пример возвращает FALSE, поскольку не все записи в таблице OrderDetails имеют значение quantity = 10):
Пример
SELECT ProductName
FROM Products
WHERE ProductID = ALL (SELECT ProductID FROM OrderDetails WHERE Quantity = 10);


SQL - Операторы ANY и ALL
Операторы ANY и ALL используются с предложением WHERE или HAVING. Оператор ANY возвращает true, если какое-либо из значений подзапроса соответствует условию. Оператор ALL возвращает true, если все значения подзапроса удовлетворяют условию.
Синтаксис ANY
SELECT column_name(s)
FROM table_name
WHERE column_name operator ANY
(SELECT column_name FROM table_name WHERE condition);
Синтаксис ALL
SELECT column_name(s)
FROM table_name
WHERE column_name operator ALL
(SELECT column_name FROM table_name WHERE condition);
Пример ANY
Оператор ANY возвращает TRUE, если какое-либо из значений подзапроса соответствует условию. Следующий оператор SQL возвращает TRUE и перечисляет имена товаров, если он находит ЛЮБЫЕ записи в таблице info, с количеством = 15:
Пример:
SELECT name
FROM product
WHERE product_id = ANY (SELECT product_id FROM info WHERE counts = 15);
Следующий оператор SQL возвращает TRUE и перечисляет имена товаров, если он находит ЛЮБЫЕ записи в таблице info, с количеством > 15:
Пример:
SELECT name
FROM product
WHERE product_id = ANY (SELECT product_id FROM info WHERE counts > 15);
Пример ALL
Оператор ALL возвращает TRUE, если все значения подзапроса удовлетворяют условию.
Следующий оператор SQL возвращает TRUE и перечисляет имена товаров, если ВСЕ записи в таблице info имеют количество = 7:
Пример:
SELECT name
FROM product
WHERE product_id = ALL (SELECT product_id FROM info WHERE couns =7);




</details>
