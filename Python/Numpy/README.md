### Numpy

#### 1. Являются ли массивы Python NumPy лучше списков?

<details>
<summary>Ответ</summary>
Массивы Python NumPy используются вместо списка по следующим трем причинам:

1. меньший объем памяти;

2. быстрее;

3. удобнее.
</details>

#### 2. Как вычислять процентили с помощью NumPy?

<details>
<summary>Ответ</summary>
Медиана - это 50 процентиль по определению. 25 процентиль указывает, что 25% наблюдаемых меньше числа в процентиле, то есть n процентов наблюдаемых значений меньше значения в процентиле n.

Можно вычислить медиану с помощью NumPy, используя следующий код:

```
import numpy as np

a = np.array([i for i in range(100)])
p = np.percentile(a, 50) # Возвращает 50-ый перцентиль - медиану

print(p)
```
</details>

#### 3. Как объединить два массива?
<details>
<summary>Ответ</summary>
Для объединения массивов нужно использовать соответствующую функцию Numpy:

```
import numpy as np

a = np.array([1, 2, 3])
b = np.array([4, 5, 6])

np.concatenate((a,b))
#=> array([1, 2, 3, 4, 5, 6])
```
</details>


#### Что такое np.arange()?
<details>
<summary>Ответ</summary>

Функция _arange()_ аналогична по своему назначению функции _range()_ из стандартной библиотеки Python. Основное отличие заключается в том, что _arange()_ позволяет строить вектор с указанием шага в виде десятичной дроби.

Синтаксис функции следующий:
```
arange(stop)

arange(start, stop)

arange(start, stop, step)
```

В первом варианте будет создан вектор из целых чисел от 0 до stop.
```
np.arange(10)
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
```
Второй вариант позволяет задавать интервал, в этом случае вектор также будет содержать целые числа.
```
np.arange(5, 12)
array([ 5,  6, 7, 8, 9, 10, 11])
```
Третий вариант позволяет определить интервал чисел и шаг, который может быть десятичным числом
```
np.arange(1, 5, 0.5)
array([1. , 1.5, 2. , 2.5, 3. , 3.5, 4. , 4.5])
```
</details>


#### Что такое np.matrix()?
<details>
<summary>Ответ</summary>
       
_Matrix_ является удобным инструментом для задания матрицы.

Вариант со списком Python.
```
>>> a = [[1, 2], [3, 4]]
>>> np.matrix(a)
matrix([[1, 2],
       [3, 4]])
```
Вариант с массивом Numpy.
```
>>> b = np.array([[5, 6], [7, 8]])
>>> np.matrix(b)
matrix([[5, 6],
       [7, 8]])
```
Вариант в Matlab стиле.
```
>>> np.matrix('[1, 2; 3, 4]')
matrix([[1, 2],
       [3, 4]])
```
</details>

#### Что такое np.zeros() и np.eye()?
<details>
<summary>Ответ</summary>
В Numpy есть функции для создания специальных матриц: нулевых и единичных.
       
_Нулевая матрица_ - это матрица, состоящая полностью из нулей. Для ее создания удобно использовать функцию zeros(), в качестве аргумента в нее передается кортеж из двух элементов, первый из них – это количество строк, второй – столбцов.

```
>>> np.zeros((3, 4))
array([[0., 0., 0., 0.],
      [0., 0., 0., 0.],
      [0., 0., 0., 0.]])
```
Функция eye() создает единичную матрицу – квадратную матрицу, у которой элементы главной диагонали равны единицы, все остальные – нулю.
```
>>> np.eye(3)
array([[1., 0., 0.],
      [0., 1., 0.],
      [0., 0., 1.]])
```

</details>

#### Как выполнить сложение матриц?
<details>
<summary>Ответ</summary>

Сложение выполняется просто используя знак "+". Важно помнить, что для выполнения сложения (вычитания) матриц, необходимо, чтобы они были одинаковыми по размеру! 
>>> A + B
matrix([[ 6,  8],
       [10, 12]])


</details>


#### Вычитание матриц
<details>
<summary>Ответ</summary>

Вычитание выполняется просто используя знак "-". Важно помнить, что для выполнения сложения (вычитания) матриц, необходимо, чтобы они были одинаковыми по размеру!
>>> A - B
matrix([[-4, -4],
       [-4, -4]])


</details>


#### Умножение матрицы на число
<details>
<summary>Ответ</summary>

Важно помнить, что для того чтобы умножить матрицу на число, нужно каждый элемент матрицы умножить на данное число.
>>> 3 * A
matrix([[ 3,  6],
       [ 9, 12]])


</details>


#### Умножение матриц
<details>
<summary>Ответ</summary>

Важно помнить, чтобы матрицу К можно было умножить на матрицу L нужно, чтобы число столбцов матрицы К равнялось числу строк матрицы L.
>>> A.dot(B)
matrix([[19, 22],
       [43, 50]])


</details>


#### Транспонирование матриц
<details>
<summary>Ответ</summary>

Для того чтобы транспонировать матрицу, нужно ее строки записать в столбцы. Другими словами, нужно столбцы и строки поменять местами.
>>> A.T
matrix([[1, 3],
       [2, 4]])
>>> np.transpose(A)
matrix([[1, 3],
       [2, 4]])


</details>

#### Для чего используется функция np.ravel()?
<details>
<summary>Ответ</summary>
Функция np.ravel() используется для того, чтобы преобразовать матрицу в одномерный вектор.

Создадим двумерную матрицу размера 3х3.

>>> A = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
>>> A
array([[1, 2, 3],
      [4, 5, 6],
      [7, 8, 9]])
Применим функцию ravel() к этой матрице.

>>> np.ravel(A)
array([1, 2, 3, 4, 5, 6, 7, 8, 9])
У ravel() есть параметр order, который отвечает за порядок построения одномерного массива, по умолчанию он равен ‘C’, что означает – массив будет собираться из строк исходной матрицы.

>>> np.ravel(A, order='C')
array([1, 2, 3, 4, 5, 6, 7, 8, 9])
Если указать order=‘F‘, то в качестве элементов для сборки будут выступать столбцы матрицы.

>>> np.ravel(A, order='F')
array([1, 4, 7, 2, 5, 8, 3, 6, 9])


</details>


#### np.where()
<details>
<summary>Ответ</summary>
Данная функция возвращает один из двух заданных элементов в зависимости от условия. Ее можно использовать для обработки численных данных.

>>> a = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> np.where(a % 2 == 0, a * 10, a / 10)
array([ 0. ,  0.1, 20. , 0.3, 40. ,  0.5, 60. , 0.7, 80. , 0.9])
В задачах машинного обучения эта функция хорошо подходит для реализации обработки данных с помощью пороговой функции.

>>> a = np.random.rand(10)
>>> a
array([0.99379074, 0.98387541, 0.2043767 , 0.11935986, 0.01063287,
      0.11146634, 0.50504848, 0.96046102, 0.3645473 , 0.6843563 ])
>>> np.where(a > 0.5, True, False)
array([ True,  True, False, False, False, False,  True, True, False,
       True])
>>> np.where(a > 0.5, 1, -1)
array([ 1,  1, -1, -1, -1, -1,  1, 1, -1, 1])


</details>


#### np.meshgrid()
<details>
<summary>Ответ</summary>
Функция meshgrid() позволят получить матрицу координат из координатных векторов. Если, например, у нас есть два одномерных вектора координат, то передав их в качестве аргументов в meshgrid() мы получим две матрицы, в которой элементы будут составлять пары, заполняя все пространство, определяемое этими векторами. Проще посмотреть это на примере.

Создадим два вектора

>>> x = np.linspace(0, 1, 5)
>>> x
array([0.  , 0.25, 0.5 , 0.75, 1.  ])
>>> y = np.linspace(0, 2, 5)
>>> y
array([0. , 0.5, 1. , 1.5, 2. ])
Построим матрицу координат с помощью meshgrid.

>>> xg, yg = np.meshgrid(x, y)
>>> xg
array([[0.  , 0.25, 0.5 , 0.75, 1.  ],
      [0. , 0.25, 0.5 , 0.75, 1.  ],
      [0. , 0.25, 0.5 , 0.75, 1.  ],
      [0. , 0.25, 0.5 , 0.75, 1.  ],
      [0. , 0.25, 0.5 , 0.75, 1.  ]])
>>> yg
array([[0. , 0. , 0. , 0. , 0. ],
      [0.5, 0.5, 0.5, 0.5, 0.5],
      [1. , 1. , 1. , 1. , 1. ],
      [1.5, 1.5, 1.5, 1.5, 1.5],
      [2. , 2. , 2. , 2. , 2. ]])
Посмотрите внимательно на матрицы xg и yg. Каждому элементу xg[i,j] соответствует свой элемент yg[i,j]. Можно визуализировать эти данные.

Для начала импортируем matplotlib (он должен быть установлен).

import matplotlib.pyplot as plt
%matplotlib inline
Последняя строка нужна, если вы работаете в Jupyter Notebook, чтобы графики рисовались “по месту”.

Теперь построим график

plt.plot(xg, yg, color="r", marker="*",  linestyle="none")

https://devpractice.ru/numpy-useful-functions/
</details>



#### np.random.permutation()
<details>
<summary>Ответ</summary>
Функция permutation() либо генерирует список заданной длины из натуральных чисел от нуля до указанного числа, либо перемешивает переданный ей в качестве аргумента массив.

>>> np.random.permutation(7)
array([6, 2, 5, 1, 0, 4, 3])
>>> a = ['a', 'b', 'c', 'd', 'e']
>>> np.random.permutation(a)
array(['c', 'd', 'a', 'e', 'b'], dtype='<U1')
Основное практическое применение эта функция находит в задачах машинного обучения, где довольно часто требуется перемешать выборку данных перед тем, как передавать ее в алгоритм.

Например у нас есть вектор с данными

>>> arr = np.linspace(0, 10, 5)
>>> arr
array([ 0. ,  2.5, 5. , 7.5, 10. ])
Перемешаем эту выборку

>>> arr_mix = np.random.permutation(arr)
>>> arr_mix
array([ 2.5,  0. , 5. , 10. ,  7.5])
Построим массив индексов для вектора arr, в котором позиции находятся в случайном порядке

>>> index_mix = np.random.permutation(len(arr_mix))
>>> index_mix
array([2, 4, 3, 1, 0])
>>> arr[index_mix]
array([ 5. , 10. ,  7.5, 2.5, 0. ])


</details>


#### ndarray.ndim
<details>
<summary>Ответ</summary>
Возвращает количество измерений массива.

import numpy as np
a = np.array([[1,2,3],[4,5,6]])
print(a.ndim)
Вывод кода сверху будет 2, поскольку «a» — это 2-мерный массив.


</details>


#### ndarray.shape
<details>
<summary>Ответ</summary>
Возвращает кортеж размера массива, то есть (n,m), где n — это количество строк, а m — количество колонок.

import numpy as np
a = np.array([[1,2,3],[4,5,6]])
print(a.shape)
Вывод кода — (2,3), то есть 2 строки и 3 колонки.


</details>

#### ndarray.size
<details>
<summary>Ответ</summary>
Возвращает общее количество элементов в массиве.

import numpy as np
a = np.array([[1,2,3],[4,5,6]])
print(a.size)
Вывод — 6, потому что 2 х 3.


</details>


#### ndarray.dtype
<details>
<summary>Ответ</summary>
Возвращает объект, описывающий тип элементов в массиве.

import numpy as np
a = np.array([[1,2,3],[4,5,6]])
print(a.dtype)
Вывод — «int32», поскольку это 32-битное целое число.
Можно явно определить тип данных массива NumPy.

import numpy as np
a = np.array([[1,2,3],[4,5,6]], dtype = float)
print(a.dtype)
Этот код вернет float64, потому что это 64-битное число с плавающей точкой.


</details>


#### ndarray.itemsize
<details>
<summary>Ответ</summary>
Возвращает размер каждого элемента в массиве в байтах.

import numpy as np
a = np.array([[1,2,3],[4,5,6]])
print(a.itemsize)
Вывод — 4, потому что 32/8.


</details>


#### ndarray.data
<details>
<summary>Ответ</summary>
Возвращает буфер с актуальными элементами массива. Это альтернативный способ получения доступа к элементам через их индексы.

import numpy as np
a = np.array([[1,2,3],[4,5,6]])
print(a.data)
Этот код вернет список элементов.


</details>


#### ndarray.sum()
<details>
<summary>Ответ</summary>
Функция вернет сумму все элементов ndarray.

import numpy as np
a = np.random.random((2,3))
print(a)
print(a.sum())
Сгенерированная в этом примере матрица — [[0.46541517 0.66668157 0.36277909] [0.7115755 0.57306008 0.64267163]], следовательно код вернет 3.422183052180838. Поскольку используется генератор случайных чисел, ваш результат будет отличаться.




</details>


#### ndarray.min()
<details>
<summary>Ответ</summary>
Функция вернет элемент с минимальным значением из ndarray.

import numpy as np
a = np.random.random((2,3))
print(a.min())
Сгенерированная в этом примере матрица — [[0.46541517 0.66668157 0.36277909] [0.7115755 0.57306008 0.64267163]], следовательно код вернет 0.36277909. Поскольку используется генератор случайных чисел, ваш результат будет отличаться.


</details>


#### ndarray.max()
<details>
<summary>Ответ</summary>
Функция вернет элемент с максимальным значением из ndarray.

import numpy as np
a = np.random.random((2,3))
print(a.min())
Сгенерированная в этом примере матрица — [[0.46541517 0.66668157 0.36277909] [0.7115755 0.57306008 0.64267163]], следовательно код вернет 0.7115755. Поскольку используется генератор случайных чисел, ваш результат будет отличаться


</details>


#### numpy.zeroes()
<details>
<summary>Ответ</summary>
numpy.zeros((rows, columns), dtype)
Эта функция создаст массив numpy с заданным количеством измерений, где каждый элемент будет равняться 0. Если dtype не указан, по умолчанию будет использоваться dtype.

import numpy as np
np.zeros((3,3))
print(a)
Код вернет массив numpy 3×3, где каждый элемент равен 0.


</details>


#### numpy.ones()
<details>
<summary>Ответ</summary>
numpy.ones((rows,columns), dtype)
Эта функция создаст массив numpy с заданным количеством измерений, где каждый элемент будет равняться 1. Если dtype не указан, по умолчанию будет использоваться dtype.

import numpy as np
np.ones((3,3))
print(a)
Код вернет массив numpy 3 x 3, где каждый элемент равен 1.


</details>


#### numpy.empty()
<details>
<summary>Ответ</summary>
numpy.empty((rows,columns))
Эта функция создаст массив, содержимое которого будет случайным — оно зависит от состояния памяти.

import numpy as np
np.empty((3,3))
print(a)
Код вернет массив numpy 3×3, где каждый элемент будет случайным.


</details>

#### numpy.arrange()
<details>
<summary>Ответ</summary>
numpy.arrange(start, stop, step)
Эта функция используется для создания массива numpy, элементы которого лежат в диапазоне значений от start до stop с разницей равной step.

import numpy as np
a=np.arange(5,25,4)
print(a)
Вывод этого кода — [5 9 13 17 21]


</details>

#### numpy.linspace()
<details>
<summary>Ответ</summary>
numpy.linspace(start, stop, num_of_elements)
Эта функция создаст массив numpy, элементы которого лежат в диапазоне значений между start до stop, а num_of_elements — это размер массива. Тип по умолчанию — float64.

import numpy as np
a=np.linspace(5,25,5)
print(a)
Вывод — [5 10 15 20 25].




</details>

#### numpy.logspace()
<details>
<summary>Ответ</summary>
numpy.logspace(start, stop, num_of_elements)
Эта функция используется для создания массива numpy, элементы которого лежат в диапазоне значений от start до stop, а num_of_elements — это размер массива. Тип по умолчанию — float64. Все элементы находятся в пределах логарифмической шкалы, то есть представляют собой логарифмы соответствующих элементов.

import numpy as np
a = np.logspace(5,25,5)
print(a)
Вывод — [1.e+05 1.e+10 1.e+15 1.e+20 1.e+25]


</details>

#### numpy.sin()
<details>
<summary>Ответ</summary>
numpy.sin(numpy.ndarray)
Этот код вернет синус параметра.

import numpy as np
a = np.logspace(5,25,2)
print(np.sin(a))
Вывод кода сверху равен [0.0357488 -0.3052578]. Также есть cos(), tan() и так далее.


</details>

#### Для чего используется numpy.reshape()?
<details>
<summary>Ответ</summary>

Эта функция используется для изменения количества измерений массива numpy. От количества аргументов в _reshape_ зависит, сколько измерений будет в массиве _numpy_.

Синтаксис следующий:
```
numpy.reshape(dimensions)
```


import numpy as np
a = np.arange(9).reshape(3,3)
print(a)
Вывод этого года — 2-мерный массив 3×3.

</details>

#### Для чего используется numpy.random.random()?
<details>
<summary>Ответ</summary>

Эта функция возвращает массив с заданным количеством измерений, где каждый элемент генерируется случайным образом.

Синтаксис следующий:
```
numpy.random.random((rows, column))
```
```
a = np.random.random((2,2))
```
Этот код вернет ndarray 2×2 (то есть матрицу случайных элементов).

</details>

#### Для чего используется numpy.exp()?
<details>
<summary>Ответ</summary>

Функция вернет ndarray с экспоненциальной величиной каждого элемента.

_Экспоненциальное (оказательное) распределение_ - абсолютно непрерывное распределение, моделирующее время между двумя последовательными свершениями одного и того же события.

Экспоненциальное распределение моделирует время между двумя последовательными свершениями события, а параметр λ описываетс среднее число наступлений события в единицу времени. Обычно с помощью этого закона описывают: продолжительность обслуживания покупателя, время жизни оборудования до отказа, промежуток времени между поломками и т.п.

Синтаксис следующий:
```
numpy.exp(numpy.ndarray)
```
```
b = np.exp([10])
```
Этот код вернёт значение 22025.4657948

</details>

#### Для чего используется numpy.sqrt()?
<details>
<summary>Ответ</summary>

Эта функция вернет ndarray с квадратным корнем каждого элемента.

Синтаксис следующий:
```
numpy.sqrt(numpy.ndarray)
```

```
b = np.sqrt([16])
```
Этот код вернет значение 4.


</details>

https://habr.com/ru/articles/352678/

https://habr.com/ru/articles/768188/


#### 
<details>
<summary>Ответ</summary>



</details>

#### 
<details>
<summary>Ответ</summary>



</details>

#### 
<details>
<summary>Ответ</summary>



</details>

#### 
<details>
<summary>Ответ</summary>



</details>

#### 
<details>
<summary>Ответ</summary>



</details>

#### 
<details>
<summary>Ответ</summary>



</details>
