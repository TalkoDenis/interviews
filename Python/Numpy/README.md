Нампай

#### 1. Являются ли массивы Python NumPy лучше списков?

<details>
<summary>Ответ</summary>
Массивы Python NumPy используются вместо списка по следующим трем причинам:

1. меньший объем памяти;

2. быстрее;

3. удобнее.
</details>

#### 2. Как вычислять процентили с помощью NumPy?

<details>
<summary>Ответ</summary>
Медиана - это 50 процентиль по определению. 25 процентиль указывает, что 25% наблюдаемых меньше числа в процентиле, то есть n процентов наблюдаемых значений меньше значения в процентиле n.

Мы можем вычислить его с помощью NumPy, используя следующий код:

import numpy as np
a = np.array([i for i in range(100)])
p = np.percentile(a, 50) # Возвращает 50-ый перцентиль - медиану
print(p)
</details>

#### 3. Как объединить два массива?
<details>
<summary>Ответ</summary>
Для объединения массивов нужно использовать соответствующую функцию Numpy:

import numpy as np

a = np.array([1, 2, 3])
b = np.array([4, 5, 6])

np.concatenate((a,b))
#=> array([1, 2, 3, 4, 5, 6])
</details>


#### Что такое np.arange()?
<details>
<summary>Ответ</summary>
Функция arange() аналогична по своему назначению функции range() из стандартной библиотеки Python. Ее основное отличие заключается в том, что arange() позволяет строить вектор с указанием шага в виде десятичной дроби.

Синтаксис использования функции следующий:

arange(stop)

arange(start, stop)

arange(start, stop, step)

В первом варианте будет создан вектор из целых чисел от 0 до stop.

>>> np.arange(10)
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
Второй вариант позволяет задавать интервал, в этом случае вектор также будет содержать целые числа.

>>> np.arange(5, 12)
array([ 5,  6, 7, 8, 9, 10, 11])
Третий вариант позволяет определить интервал чисел и шаг, который может быть десятичным числом

>>> np.arange(1, 5, 0.5)
array([1. , 1.5, 2. , 2.5, 3. , 3.5, 4. , 4.5])

</details>


#### Что такое np.matrix()?
<details>
<summary>Ответ</summary>
Matrix является удобным инструментом для задания матрицы. При этом можно использовать Matlab стиль, либо передать в качестве аргумента список Python (или массив Numpy).

Вариант со списком Python.

>>> a = [[1, 2], [3, 4]]
>>> np.matrix(a)
matrix([[1, 2],
       [3, 4]])
Вариант с массивом Numpy.

>>> b = np.array([[5, 6], [7, 8]])
>>> np.matrix(b)
matrix([[5, 6],
       [7, 8]])
Вариант в Matlab стиле.

>>> np.matrix('[1, 2; 3, 4]')
matrix([[1, 2],
       [3, 4]])
</details>

#### np.zeros(), np.eye()
<details>
<summary>Ответ</summary>
В арсенале Numpy есть функции для создания специальных матриц: нулевых и единичных. Нулевой называется матрица, состоящая полностью из нулей. Для ее создания удобно использовать функцию zeros(), в качестве аргумента в нее передается кортеж из двух элементов, первый из них – это количество строк, второй – столбцов.

>>> np.zeros((3, 4))
array([[0., 0., 0., 0.],
      [0., 0., 0., 0.],
      [0., 0., 0., 0.]])
Функция eye() создает единичную матрицу – квадратную матрицу, у которой элементы главной диагонали равны единицы, все остальные – нулю.

>>> np.eye(3)
array([[1., 0., 0.],
      [0., 1., 0.],
      [0., 0., 1.]])


</details>



#### Сложение матриц
<details>
<summary>Ответ</summary>
>>> A + B
matrix([[ 6,  8],
       [10, 12]])


</details>


#### Вычитание матриц
<details>
<summary>Ответ</summary>
>>> A - B
matrix([[-4, -4],
       [-4, -4]])


</details>


#### Умножение матрицы на число
<details>
<summary>Ответ</summary>
>>> 3 * A
matrix([[ 3,  6],
       [ 9, 12]])


</details>


#### Умножение матриц
<details>
<summary>Ответ</summary>
>>> A.dot(B)
matrix([[19, 22],
       [43, 50]])


</details>


#### Транспонирование матриц
<details>
<summary>Ответ</summary>
>>> A.T
matrix([[1, 3],
       [2, 4]])
>>> np.transpose(A)
matrix([[1, 3],
       [2, 4]])


</details>

#### np.ravel()
<details>
<summary>Ответ</summary>
Функция np.ravel() используется для того, чтобы преобразовать матрицу в одномерный вектор.

Создадим двумерную матрицу размера 3х3.

>>> A = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
>>> A
array([[1, 2, 3],
      [4, 5, 6],
      [7, 8, 9]])
Применим функцию ravel() к этой матрице.

>>> np.ravel(A)
array([1, 2, 3, 4, 5, 6, 7, 8, 9])
У ravel() есть параметр order, который отвечает за порядок построения одномерного массива, по умолчанию он равен ‘C’, что означает – массив будет собираться из строк исходной матрицы.

>>> np.ravel(A, order='C')
array([1, 2, 3, 4, 5, 6, 7, 8, 9])
Если указать order=‘F‘, то в качестве элементов для сборки будут выступать столбцы матрицы.

>>> np.ravel(A, order='F')
array([1, 4, 7, 2, 5, 8, 3, 6, 9])


</details>


#### np.where()
<details>
<summary>Ответ</summary>
Данная функция возвращает один из двух заданных элементов в зависимости от условия. Ее можно использовать для обработки численных данных.

>>> a = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> np.where(a % 2 == 0, a * 10, a / 10)
array([ 0. ,  0.1, 20. , 0.3, 40. ,  0.5, 60. , 0.7, 80. , 0.9])
В задачах машинного обучения эта функция хорошо подходит для реализации обработки данных с помощью пороговой функции.

>>> a = np.random.rand(10)
>>> a
array([0.99379074, 0.98387541, 0.2043767 , 0.11935986, 0.01063287,
      0.11146634, 0.50504848, 0.96046102, 0.3645473 , 0.6843563 ])
>>> np.where(a > 0.5, True, False)
array([ True,  True, False, False, False, False,  True, True, False,
       True])
>>> np.where(a > 0.5, 1, -1)
array([ 1,  1, -1, -1, -1, -1,  1, 1, -1, 1])


</details>


#### np.meshgrid()
<details>
<summary>Ответ</summary>
Функция meshgrid() позволят получить матрицу координат из координатных векторов. Если, например, у нас есть два одномерных вектора координат, то передав их в качестве аргументов в meshgrid() мы получим две матрицы, в которой элементы будут составлять пары, заполняя все пространство, определяемое этими векторами. Проще посмотреть это на примере.

Создадим два вектора

>>> x = np.linspace(0, 1, 5)
>>> x
array([0.  , 0.25, 0.5 , 0.75, 1.  ])
>>> y = np.linspace(0, 2, 5)
>>> y
array([0. , 0.5, 1. , 1.5, 2. ])
Построим матрицу координат с помощью meshgrid.

>>> xg, yg = np.meshgrid(x, y)
>>> xg
array([[0.  , 0.25, 0.5 , 0.75, 1.  ],
      [0. , 0.25, 0.5 , 0.75, 1.  ],
      [0. , 0.25, 0.5 , 0.75, 1.  ],
      [0. , 0.25, 0.5 , 0.75, 1.  ],
      [0. , 0.25, 0.5 , 0.75, 1.  ]])
>>> yg
array([[0. , 0. , 0. , 0. , 0. ],
      [0.5, 0.5, 0.5, 0.5, 0.5],
      [1. , 1. , 1. , 1. , 1. ],
      [1.5, 1.5, 1.5, 1.5, 1.5],
      [2. , 2. , 2. , 2. , 2. ]])
Посмотрите внимательно на матрицы xg и yg. Каждому элементу xg[i,j] соответствует свой элемент yg[i,j]. Можно визуализировать эти данные.

Для начала импортируем matplotlib (он должен быть установлен).

import matplotlib.pyplot as plt
%matplotlib inline
Последняя строка нужна, если вы работаете в Jupyter Notebook, чтобы графики рисовались “по месту”.

Теперь построим график

plt.plot(xg, yg, color="r", marker="*",  linestyle="none")

https://devpractice.ru/numpy-useful-functions/
</details>



#### np.random.permutation()
<details>
<summary>Ответ</summary>
Функция permutation() либо генерирует список заданной длины из натуральных чисел от нуля до указанного числа, либо перемешивает переданный ей в качестве аргумента массив.

>>> np.random.permutation(7)
array([6, 2, 5, 1, 0, 4, 3])
>>> a = ['a', 'b', 'c', 'd', 'e']
>>> np.random.permutation(a)
array(['c', 'd', 'a', 'e', 'b'], dtype='<U1')
Основное практическое применение эта функция находит в задачах машинного обучения, где довольно часто требуется перемешать выборку данных перед тем, как передавать ее в алгоритм.

Например у нас есть вектор с данными

>>> arr = np.linspace(0, 10, 5)
>>> arr
array([ 0. ,  2.5, 5. , 7.5, 10. ])
Перемешаем эту выборку

>>> arr_mix = np.random.permutation(arr)
>>> arr_mix
array([ 2.5,  0. , 5. , 10. ,  7.5])
Построим массив индексов для вектора arr, в котором позиции находятся в случайном порядке

>>> index_mix = np.random.permutation(len(arr_mix))
>>> index_mix
array([2, 4, 3, 1, 0])
>>> arr[index_mix]
array([ 5. , 10. ,  7.5, 2.5, 0. ])


</details>


#### 
<details>
<summary>Ответ</summary>



</details>


#### 
<details>
<summary>Ответ</summary>



</details>
