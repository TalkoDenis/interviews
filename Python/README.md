

#### 1. В чем разница между списком и кортежем?
<details>
<summary>Ответ</summary>
- Список можно изменить после создания. Список упорядочен. Он представляет собой упорядоченные последовательности объектов, как правило, одного и того же типа. Например, все имена пользователей упорядочены по дате создания: ["Seth", "Ema", "Eli"].
  
- Кортеж нельзя изменить после создания. У кортежа есть структура. В каждом индексе могут сосуществовать различные типы данных. Например, такая запись базы данных в памяти: (2, "Ema", "2020–04–16") # id, name, created_at.
</details>

#### 2. Как выполняется интерполяция строк?

Без импорта класса Template есть три способа интерполяции строк:

name = 'Chris'

# 1. f strings
print(f'Hello {name}')

# 2. % operator
print('Hey %s %s' % (name, name))

# 3. format
print(
 "My name is {}".format((name))
)

#### 3. В чем разница между is и ==?

is проверяет идентичность, а == проверяет равенство.

Рассмотрим пример. Создайте несколько списков и назначьте им имена. Обратите внимание, что ниже b указывает на тот же объект, что и a:

a = [1,2,3]
b = a
c = [1,2,3]

Проверьте равенство и обратите внимание, что все объекты равны:

print(a == b)
print(a == c)
#=> True
#=> True

Но являются ли все они идентичными? Нет:

print(a is b)
print(a is c)
#=> True
#=> False

Можем проверить это, распечатав их идентификаторы объектов:

print(id(a))
print(id(b))
print(id(c))

В вашем случае тут будут совершенно другие значения!

#=> 4369567560
#=> 4369567560
#=> 4369567624

Идентификатор c отличается от идентификатора a и b.

#### 4. Что такое декоратор?

Декоратор позволяет добавить новую функциональность к существующей функции. Это делается следующим образом. Функция передается декоратору, а он выполняет и существующий, и дополнительный код.

Напишем декоратор, который записывает в журнал вызовы другой функции.

Напишите функцию декоратора. В качестве аргумента он принимает функцию func. Декоратор определяет функцию log_function_called, которая вызывает func() и выполняет некоторый код print(f'{func} called.'). Затем возвращает определенную им функцию:

def logging(func):
 def log_function_called():
   print(f'{func} called.')
   func()
 return log_function_called

Напишем другие функции, к которым добавим декоратор (потом, не сейчас):

def my_name():
  print('chris')
def friends_name():
  print('naruto')
my_name()
friends_name()
#=> chris
#=> naruto

Теперь добавим декоратор к ним обоим:

@logging
def my_name():
 print('chris')

@logging
def friends_name():
 print('naruto')

my_name()
friends_name()
#=> <function my_name at 0x10fca5a60> called.
#=> chris
#=> <function friends_name at 0x10fca5f28> called.
#=> naruto

Теперь легко добавить ведение журнала в любую функцию, которую мы пишем. Достаточно написать перед ней @logging.

#### 5. Объясните функцию range

Range генерирует список целых чисел. Ее можно использовать тремя способами.

Функция принимает от одного до трех аргументов. Обратите внимание, что я завернул каждый пример в список, чтобы видеть генерируемые значения.

range(stop) — генерирует целые числа от 0 до целого числа stop:

[i for i in range(10)]
#=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

range(start, stop) — генерирует целые числа от start до stop:

[i for i in range(2,10)]
#=> [2, 3, 4, 5, 6, 7, 8, 9]

range(start, stop, step) — генерирует целые числа от start до stop с интервалами step:

[i for i in range(2,10,2)]
#=> [2, 4, 6, 8]

Серж Боремчук предложил более подходящий способ:

list(range(2,10,2))
#=> [2, 4, 6, 8]

#### 6. Определите класс car с двумя атрибутами: color и speed. Затем создайте экземпляр и верните speed

Вот как это сделать:

class Car :
    def __init__(self, color, speed):
        self.color = color
        self.speed = speed
car = Car('red','100mph')
car.speed
#=> '100mph'

#### 7. В чем разница между методами экземпляра, класса и статическими методами в Python?

Методы экземпляра: принимают параметр self и относятся к определенному экземпляру класса.

Статические методы: используют декоратор @staticmethod, не связаны с конкретным экземпляром и являются автономными (атрибуты класса или экземпляра не изменяются).

Методы класса: принимают параметр cls, можно изменить сам класс.

Проиллюстрируем разницу на вымышленном классе CoffeeShop:

class CoffeeShop:
    specialty = 'espresso'

    def __init__(self, coffee_price):
        self.coffee_price = coffee_price
  
    # instance method
    def make_coffee(self):
        print(f'Making {self.specialty} for ${self.coffee_price}')
 
    # static method    
    @staticmethod
    def check_weather():
        print('Its sunny')

    # class method
    @classmethod
    def change_specialty(cls, specialty):
        cls.specialty = specialty
        print(f'Specialty changed to {specialty}')

У класса CoffeeShop есть атрибут specialty (фирменный напиток), установленный по умолчанию в значение 'espresso'. Каждый экземпляр CoffeeShop инициализируется с атрибутом coffee_price. У него также три метода: метод экземпляра, статический метод и метод класса.

Давайте инициализируем экземпляр с атрибутом coffee_price, равным 5. Затем вызовем метод экземпляра make_coffee:

coffee_shop = CoffeeShop('5')
coffee_shop.make_coffee()
#=> Making espresso for $5

Теперь вызовем статический метод. Статические методы не могут изменять состояние класса или экземпляра, поэтому обычно используются для служебных функций, например, сложения двух чисел. Наши проверяют погоду. Говорят, что солнечно. Отлично!

coffee_shop.check_weather()
#=> Its sunny

Теперь используем метод класса для изменения фирменного напитка (specialty), а затем сделаем кофе (make_coffee):

coffee_shop.change_specialty('drip coffee')
#=> Specialty changed to drip coffee

coffee_shop.make_coffee()
#=> Making drip coffee for $5

Обратите внимание, что make_coffee раньше делал эспрессо, а теперь заваривает капельную кофеварку (drip coffee).

#### 8. В чем разница между func и func()?

Вопрос должен проверить ваше понимание, что все функции в Python также являются объектами:

def func():
    print('Im a function')

func
#=> function __main__.func>
func()    
#=> Im a function

func — это представляющий функцию объект, который можно назначить переменной или передать другой функции. Функция func() с круглыми скобками вызывает функцию и возвращает результат.

#### 9. Объясните, как работает функция map

Она возвращает объект (итератор), который перебирает значения, применяя функцию к каждому элементу. В случае необходимости объект можно преобразовать в список:

def add_three(x):
    return x + 3
li = [1,2,3]
list(map(add_three, li))
#=> [4, 5, 6]

Здесь к каждому элементу в списке мы добавляем число 3.

#### 10. Объясните, как работает функция reduce

Это может быть сложновато сразу понять, пока вы не используете ее несколько раз.

reduce принимает функцию и последовательность — и проходит по этой последовательности. На каждой итерации в функцию передаются как текущий элемент, так и выходные данные предыдущего элемента. В конце концов, возвращается одно значение:

from functools import reduce
def add_three(x,y):
    return x + y
li = [1,2,3,5]
reduce(add_three, li)
#=> 11

Возвращается 11, что является суммой 1+2+3+5.

#### 11. Объясните, как работает функция filter

Функция делает буквально то, о чем говорит ее название: она фильтрует элементы в последовательности.

Каждый элемент передается функции, которая включает его в последовательность, если по условию получает True, и отбрасывает в случае False:

def add_three(x):
    if x % 2 == 0:
        return True        
    else:
        return False

li = [1,2,3,4,5,6,7,8]

[i for i in filter(add_three, li)]
#=> [2, 4, 6, 8]

Обратите внимание, как удалены все элементы, которые не делятся на 2.

#### 12. Переменные в Python передаются по ссылке или по значению?

Будьте готовы спуститься в кроличью нору семантики, если загуглите этот вопрос и прочтете несколько первых страниц.

В общем, все имена передаются по ссылке, но в некоторых ячейках памяти хранятся объекты, а в других — указатели на другие ячейки памяти.

name = 'object'

Давайте посмотрим, как это работает со строками. Создадим экземпляр имени и объекта, на который указывают другие имена. Затем удалим первое:

x = 'some text'
y = x
x is y #=> True

del x # удаляем имя 'a' , но не объект в памяти

z = y
y is z #=> True

Мы видим, что все имена указывают на один и тот же объект в памяти, который остался нетронутым после операции удаления имени del x.

Вот еще один интересный пример с функцией:

name = 'text'
def add_chars(str1):
    print( id(str1) ) #=> 4353702856
    print( id(name) ) #=> 4353702856
  
    # новое имя, тот же объект
    str2 = str1
  
    # создаем новое имя (не отличается от предыдущего) и новый объект
    str1 += 's' 
    print( id(str1) ) #=> 4387143328
    
    # объект не изменился
    print( id(str2) ) #=> 4353702856
     
add_chars(name)
print(name) #=>text

Обратите внимание, что добавление буквы s в строку внутри функции создает новое имя — и новый объект тоже. Даже если у нового объекта то же самое имя, что и у существующего.

#### 13. Как развернуть список?

Обратите внимание, что reverse() вызывается в списке и изменяет его. Сама функция не возвращает измененный список:

li = ['a','b','c']

print(li)
li.reverse()
print(li)
#=> ['a', 'b', 'c']
#=> ['c', 'b', 'a']

#### 14. Как работает умножение строк?

Посмотрим результат умножения строки 'cat' на 3:

'cat' * 3
#=> 'catcatcat'

В результате содержимое строки повторяется трижды.

#### 15. Как работает умножение списка?

Посмотрим на результат умножения списка [1,2,3] на 2:

[1,2,3] * 2
#=> [1, 2, 3, 1, 2, 3]

Содержание списка [1,2,3] повторяется дважды.

#### 16. Что означает self в классе?

Self ссылается на экземпляр класса. Так метод может обновлять объект, к которому принадлежит.

Ниже передача self в __init__() дает возможность установить цвет экземпляра при инициализации:

class Shirt:
    def __init__(self, color):
        self.color = color
    
s = Shirt('yellow')
s.color
#=> 'yellow'

#### 17. Как объединить списки в Python?

Списки объединяются при сложении. Обратите внимание, что с массивами так не получается:

a = [1,2]
b = [3,4,5]

a + b
#=> [1, 2, 3, 4, 5]

#### 18. В чем разница между глубокой и мелкой копиями?

Обсудим это в контексте изменяемого объекта — списка. Для неизменяемых объектов глубокое и мелкое (поверхностное) копирование обычно не отличаются.

Рассмотрим три сценария.

I) Поставьте ссылку на исходный объект. Она отсылает новое имя li2 к тому же месту в памяти, на которое указывает li1. Поэтому любое изменение в li1 также происходит с li2:

li1 = [['a'],['b'],['c']]
li2 = li1

li1.append(['d'])
print(li2)
#=> [['a'], ['b'], ['c'], ['d']]

II) Создайте мелкую копию оригинала. Ее можно создать с помощью конструктора list() или mylist.copy().

Мелкая копия создает новый объект, но заполняет его ссылками на оригинал. Таким образом, добавление нового объекта в исходный список li3 не отразится в li4, а вот изменение объектов в li3 — отразится:

li3 = [['a'],['b'],['c']]
li4 = list(li3)

li3.append([4])
print(li4)
#=> [['a'], ['b'], ['c']]

li3[0][0] = ['X']
print(li4)
#=> [[['X']], ['b'], ['c']]

III) Создайте глубокую копию. Это делается с помощью copy.deepcopy(). Оригинал и копия полностью независимы, а изменения в одном не оказывают никакого влияния на другой:

import copy

li5 = [['a'],['b'],['c']]
li6 = copy.deepcopy(li5)

li5.append([4])
li5[0][0] = ['X']
print(li6)
#=> [['a'], ['b'], ['c']]

#### 19. В чем разница между списками и массивами?

Примечание: в стандартной библиотеке Python есть объект array, но здесь мы специально обсуждаем массив из популярной библиотеки Numpy.

Списки в каждом индексе можно заполнять разными типами данных. Массивы требуют однородных элементов.

Арифметические действия в списках добавляют или удаляют элементы из списка. Арифметические действия на массивах соответствуют функциям линейной алгебры.

Массивы используют меньше памяти и обладают значительно большей функциональностью.

#### 20. Как объединить два массива?

Помните, что массивы — это не списки. Это библиотека Numpy и здесь работает линейная алгебра.

Для объединения массивов нужно использовать соответствующую функцию Numpy:

import numpy as np

a = np.array([1,2,3])
b = np.array([4,5,6])

np.concatenate((a,b))
#=> array([1, 2, 3, 4, 5, 6])

#### 21. Что вам нравится в Python?

Примечание: это очень субъективный вопрос, и логично адаптировать ответ в зависимости от того, на какую должность вы претендуете.

Python очень удобочитаем, и есть так называемый «питоновский способ» решения почти любой задачи, то есть самый понятный, ясный и лаконичный код.

Это мне кажется противоположностью Ruby, где часто много способов решить задачу без четких указаний, какой вариант предпочтительнее.

#### 22. Какая ваша любимая библиотека в Python?

Примечание: это тоже субъективно, см. вопрос 21.

При работе с большим количеством данных трудно найти что-то полезнее, чем pandas. С этой библиотекой обработка и визуализация данных становятся проще простого.

#### 23. Назовите изменяемые и неизменяемые объекты

Неизменяемость означает, что состояние нельзя изменить после создания. Примеры: int, float, bool, string и tuple.

Состояние изменяемых объектов можно изменить. Примеры: list, dict и set.

#### 24. Как округлить число до трех десятичных знаков?

Используйте функцию round(value, decimal_places):

a = 5.12345
round(a,3)
#=> 5.123

#### 25. Как разбить список?

Синтаксис функции включает три аргумента: list[start:stop:step], где step — это интервал, через который возвращаются элементы:

a = [0,1,2,3,4,5,6,7,8,9]

print(a[:2])
#=> [0, 1]

print(a[8:])
#=> [8, 9]

print(a[2:8])
#=> [2, 3, 4, 5, 6, 7]

print(a[2:8:2])
#=> [2, 4, 6]

#### 26. Что такое pickle?

Pickle — это модуль сериализации и десериализации объектов в Python.

В примере ниже мы сериализуем и десериализуем список словарей:

import pickle

obj = [
    {'id':1, 'name':'Stuffy'},
    {'id':2, 'name': 'Fluffy'}
]

with open('file.p', 'wb') as f:
    pickle.dump(obj, f)

with open('file.p', 'rb') as f:
    loaded_obj = pickle.load(f)

print(loaded_obj)
#=> [{'id': 1, 'name': 'Stuffy'}, {'id': 2, 'name': 'Fluffy'}]

#### 27. Какая разница между словарями и JSON?

Dict (словарь) — это тип данных Python, представляющий собой набор индексированных, но неупорядоченных пар ключ-значение.

JSON — просто строка, которая следует заданному формату и предназначена для передачи данных.

#### 28. Какие ORM вы использовали в Python?

Технология ORM (object-relational mapping, объектно-реляционное отображение) связывает модели данных (обычно в приложении) с таблицами БД и упрощает транзакции с базой данных.

В контексте Flask обычно используется SQLAlchemy, а у Django собственная ORM.

#### 29. Как работают any() и all()?

Any возвращает true, если хоть один элемент в последовательности соответствует условию, то есть является true.

All возвращает true только в том случае, если условию соответствуют все элементы в последовательности.

a = [False, False, False]
b = [True, False, False]
c = [True, True, True]

print( any(a) )
print( any(b) )
print( any(c) )
#=> False
#=> True
#=> True

print( all(a) )
print( all(b) )
print( all(c) )
#=> False
#=> False
#=> True

#### 30. Где быстрее поиск: в словарях или списках?

Поиск значения в списке занимает O(n) времени, потому что нужно пройти весь список.

Поиск ключа в словаре занимает O(1) времени, потому что это хэш-таблица.

Разница во времени может быть огромной, если значений много, поэтому для производительности обычно рекомендуют словари. Но у них есть другие ограничения, такие как необходимость уникальных ключей.

#### 31. В чем разница между модулем и пакетом?

Модуль — это файл или набор файлов, которые импортируются вместе:

import sklearn

Пакет — это каталог с модулями:

from sklearn import cross_validation

Таким образом, пакеты — это модули, но не все модули являются пакетами.

#### 32. Как увеличить и уменьшить целое число в Python?

Инкремент и декремент можно сделать с помощью += и -=:

value = 5

value += 1
print(value)
#=> 6

value -= 1
value -= 1
print(value)
#=> 4

#### 33. Как вернуть двоичный код целого числа?

Используйте функцию bin():

bin(5)
#=> '0b101'

#### 34. Как удалить из списка дубликаты?

Это можно сделать путем преобразования списка в набор, а затем обратно в список:

a = [1,1,1,2,3]
a = list(set(a))
print(a)
#=> [1, 2, 3]

Обратите внимание, что наборы не обязательно поддерживают порядок следования списка.

#### 35. Как проверить, существует ли значение в списке?

Используйте in:

'a' in ['a','b','c']
#=> True

'a' in [1,2,3]
#=> False

#### 36. В чем разница между append и extend?

append добавляет значения в список, а extend добавляет в список значения из другого списка:

a = [1,2,3]
b = [1,2,3]

a.append(6)
print(a)
#=> [1, 2, 3, 6]

b.extend([4,5])
print(b)
#=> [1, 2, 3, 4, 5]

#### 37. Как получить абсолютное значение целого числа?

Это можно сделать с помощью функции abs():

abs(2)
#=> 2

abs(-2)
#=> 2

#### 38. Как объединить два списка в список кортежей?

Для объединения в список кортежей можно использовать функцию zip, причем не только двух, но трех и более списков.

a = ['a','b','c']
b = [1,2,3]

[(k,v) for k,v in zip(a,b)]
#=> [('a', 1), ('b', 2), ('c', 3)]

#### 39. Как отсортировать словарь по ключам, в алфавитном порядке?

Нельзя «отсортировать» словарь, поскольку словари не поддерживают упорядочение, но можно вернуть отсортированный список кортежей с ключами и значениями из словаря:

d = {'c':3, 'd':4, 'b':2, 'a':1}

sorted(d.items())
#=> [('a', 1), ('b', 2), ('c', 3), ('d', 4)]

#### 40. Как реализуется наследование классов в Python?

В приведенном ниже примере класс Audi является наследником Car. И вместе с этим наследуются методы экземпляра родительского класса:

class Car():
    def drive(self):
        print('vroom')
class Audi(Car):
    pass
audi = Audi()
audi.drive()

#### 41. Как удалить все пробелы из строки?

Можно разделить строку в местах пробелов, а затем снова соединить без пробелов:

s = 'A string with white space'

''.join(s.split())
#=> 'Astringwithwhitespace'

Двое читателей рекомендовали более каноничный способ замены, который следует духу Python, что «явное лучше, чем неявное». Он также быстрее работает, потому что здесь не создается новый объект списка:

s = 'A string with white space'
s.replace(' ', '')
#=> 'Astringwithwhitespace'

#### 42. Почему мы используем enumerate() при итерации последовательности?

enumerate() позволяет отслеживать индекс при итерации последовательности. Это более нативный способ, чем определение и приращение целого числа, представляющего индекс:

li = ['a','b','c','d','e']

for idx,val in enumerate(li):
print(idx, val)
#=> 0 a
#=> 1 b
#=> 2 c
#=> 3 d
#=> 4 e

#### 43. В чем разница между pass, continue и break?

Заглушка pass означает «ничего не делать». Обычно мы используем эту функцию, потому что Python не позволяет создавать класс, функцию или оператор if без кода внутри.

В приведенном ниже примере вылетит ошибка, если внутри i > 3 не будет кода, поэтому мы используем pass:

a = [1,2,3,4,5]
for i in a:
    if i > 3:
        pass
    print(i)
#=> 1
#=> 2
#=> 3
#=> 4
#=> 5

continue отправляет вас к следующему элементу в цикле, останавливая выполнение для текущего элемента. Таким образом, print(i) никогда не получает значения i < 3:

for i in a:
    if i < 3:
        continue
    print(i)
#=> 3
#=> 4
#=> 5

break прерывает цикл, и последовательность больше не повторяется. Таким образом, на цифре 3 цикл прерывается, а этот и следующие элементы не печатаются:

for i in a:
   if i == 3:
       break
   print(i)   
#=> 1
#=> 2

#### 44. Преобразуйте следующий цикл for в генератор списков (list comprehension)

Дан следующий цикл for:

a = [1,2,3,4,5]

a2 = []
for i in a:
     a2.append(i + 1)
print(a2)
#=> [2, 3, 4, 5, 6]

Результат:

a3 = [i+1 for i in a]

print(a3)
#=> [2, 3, 4, 5, 6]

Генератор списка обычно считается более каноническим способом в Python, если он остается понятным.

#### 45. Приведите пример тернарного оператора

Тернарный (условный) оператор — это однострочный оператор if/else.

Синтаксис такой: a if condition else b.

x = 5
y = 10

'greater' if x > 6 else 'less'
#=> 'less'

'greater' if y > 6 else 'less'
#=> 'greater'

#### 46. Проверьте, что в строке только числа

Можно использовать isnumeric():

'123a'.isnumeric()
#=> False

'123'.isnumeric()
#=> True

#### 47. Проверьте, что в строке только буквы

Можно использовать isalpha():

'123a'.isalpha()
#=> False

'a'.isalpha()
#=> True

#### 48. Проверьте, что в строке только буквы и цифры

Здесь можно использовать isalnum():

'123abc...'.isalnum()
#=> False

'123abc'.isalnum()
#=> True

#### 49. Получите список ключей из словаря

Это можно сделать через передачу словаря в конструктор list():

d = {'id':7, 'name':'Shiba', 'color':'brown', 'speed':'very slow'}

list(d)
#=> ['id', 'name', 'color', 'speed']

#### 50. Как перевести строку в верхний/нижний регистр?

Можно использовать строковые методы upper() и lower():

small_word = 'potatocake'
big_word = 'FISHCAKE'

small_word.upper()
#=> 'POTATOCAKE'

big_word.lower()
#=> 'fishcake'

#### 51. В чем разница между remove, del и pop?

remove() удаляет первое совпадающее значение:

li = ['a','b','c','d']

li.remove('b')
li
#=> ['a', 'c', 'd']

del удаляет элемент по его индексу:

li = ['a','b','c','d']

del li[0]
li
#=> ['b', 'c', 'd']

pop() удаляет элемент по индексу и возвращает этот элемент:

li = ['a','b','c','d']

li.pop(2)
#=> 'c'

li
#=> ['a', 'b', 'd']

#### 52. Приведите пример генератора словарей (dict comprehension)

Ниже мы создадим словарь с буквами алфавита в качестве ключей и индексами в качестве значений:

# создаем список букв
import string
list(string.ascii_lowercase)
alphabet = list(string.ascii_lowercase)

# генерация словаря
d = {val:idx for idx,val in enumerate(alphabet)}

d
#=> {'a': 0,
#=> 'b': 1,
#=> 'c': 2,
#=> ...
#=> 'x': 23,
#=> 'y': 24,
#=> 'z': 25}

#### 53. Как выполняется обработка исключений в Python?

Для обработки исключений Python предоставляет конструкцию из трех слов: try, except и finally.

Синтаксис выглядит примерно так:

try:
    # попробовать сделать это
except:
    # если блок try не сработал, попробовать это
finally:
    # всегда делать это

Ниже упрощенный пример такой конструкции. Здесь блок try терпит неудачу, поскольку мы не можем складывать целые числа со строками. Блок except устанавливает val = 10, а затем блок finally выводит complete:

try:
    val = 1 + 'A'
except:
    val = 10
finally:
    print('complete')
 
print(val)
#=> complete
#=> 10

Конечно, невозможно на 100% угадать, какие вопросы зададут на собеседовании. Лучший способ подготовиться — программировать и еще раз программировать, накапливая опыт.

Однако приведенный список точно поможет тем, кто готовится к собеседованию на позицию дата-сайентиста или junior/middle-разработчика Python.



Многие начинающие ученые в области данных начали свое путешествие по науке о данных с языка программирования Python. Почему Python? Потому что он легок в освоении и сегодня его используют многие компании. Более того, этот язык универсальный и предназначен не только для специалистов по обработке данных, но также используется и в целях разработчиков.

Когда вы подаете заявку на должность специалиста по обработке данных, многие компании просят пройти собеседование на работу на знание этого языка. Я попытаюсь изложить вопросы, которые собрал из многих источников и собственного опыта. Постараюсь выбрать наиболее популярные.

#### 1. Что такое Python?
Python — это язык программирования с объектами, модулями, потоками, исключениями и автоматическим управлением памятью. Python предназначен для высокой читабельности. Он часто использует английские ключевые слова, в то время как другие языки используют пунктуацию, и у него меньше синтаксических конструкций, чем у других языков.

#### 2. Каковы преимущества использования Python?
Они заключаются в том, что он прост, удобен, портативен, расширяем, имеет встроенную структуру данных и открытый исходный код.

#### 3. Как Python интерпретируется как язык?
Интерпретируемый язык — это любой язык программирования, который не находится в машинном коде до выполнения. Таким образом, Python им и является.

#### 4. Как интерпретируется Python?
Программа Python запускается непосредственно из исходного кода, написанным программистом. Язык преобразует его в промежуточный код, который снова переводится на машинный язык, который затем уже должен быть выполнен.

#### 5. Как в Python управляется память?
Память в Python управляется приватным пространством кучи Python. В ней расположены все объекты и структуры данных Python. Об этой куче заботится сам интерпретатор Python, а программист не имеет к ней доступа.
Менеджер памяти Python заботится о выделении частного пространства кучи.
Память для пространства кучи Python предоставляется встроенным сборщиком мусора, который перерабатывает и освобождает всю неиспользуемую память.
6. Что такое PEP 8?
PEP расшифровывается как Python Enhancement Proposal (Предложение по улучшению Python). Это набор правил, которые определяют, как форматировать код для максимальной читабельности.

#### 7. Как писать комментарии на Python?
Комментарии начинаются с символа #.

#Пример комментария

#### 8. Как прокомментировать несколько строк в Python?
Многострочные комментарии появляются на нескольких строках. Все строки, подлежащие комментарию, должны иметь префикс #. Можно использовать метод быстрого доступа, чтобы прокомментировать несколько строк. Все, что нужно сделать, — это удерживать клавишу ctrl и щелкнуть левой кнопкой мыши в том месте, где вы хотите включить символ #, и ввести # только один раз. Это закомментирует все строки, на которых щелкнули курсором.

#### 9. Что такое строки документации в Python?
Docstrings не являются комментариями, это строки документации. Они заключены в тройные кавычки. Такие строки не привязаны ни к одной переменной, и поэтому иногда служат в качестве комментариев.

""" 
Это строка документации
Она используется для документирования
"""
#### 10. Обязательны ли отступы в Python?
Отступ в Python является обязательным и является частью его синтаксиса.

Все языки программирования имеют некоторый способ определения объема и масштаба блока кодов — в Python это отступ. Отступ обеспечивает лучшую читабельность кода, и именно поэтому он обязателен.

#### 11. Что такое функция в Python?
Функция — это блок кода, который выполняется только при его вызове. Для определения функции Python используется ключевое слово def. Если функция возвращает что-то, ей нужно ключевое слово return.

def example(a):
   return a*2
#### 12. Что такое локальные и глобальные переменные в Python?
Глобальная переменная:

Переменные, объявленные вне функции или в глобальном пространстве, называются глобальными. Они могут быть доступны любой функции в программе.

Локальная переменная:

Любая переменная, объявленная внутри функции, называется локальной. Она присутствует в локальном пространстве, а не в глобальном.

#Пример глобальной переменной
a = 1
#Пример локальной переменной
def sample():
   #Локальная переменная
   a = 1
#### 13. Что такое лямбда-функция?
Анонимная или неназванная функция называется лямбда-функцией. Она может иметь любое количество параметров, но только один оператор. Она часто используется как одноразовая функция, а не многоразовая.

#Пример лямбда-функции
test = lambda x,y: x*y
print(test(2,4))
#### 14. Почему лямбда-формы в Python не имеют операторов?
Потому что они используются для создания нового объекта функции, а затем возвращают его во время выполнения.

#### 15. Какие типы данных поддерживаются в Python?
Python имеет пять стандартных типов данных −

• число (целочисленные и с плавающей запятой);

• строка;

• список;

• кортеж;

• словарь.

#### 16. Что такое индексы?
Чтобы получить доступ к элементу из упорядоченных последовательностей, мы используем его индекс, который является номером позиции этого конкретного элемента. Индекс обычно начинается с 0, то есть первый элемент имеет индекс 0, второй — 1 и так далее.

#Пример использования индекса
list_ex = [1,2, 'Test']
print(list_ex[0])
#### 17. Что такое отрицательные индексы и почему они используются?
Когда мы используем индекс для доступа к элементам из конца списка, это называется обратным индексированием. При нем индексация элементов начинается с последнего элемента с индексом -1. Второй последний элемент имеет индекс “-2” и так далее. Они называются отрицательными.

#Пример использования индекса
list_ex = [1,2, 'Test']
print(list_ex[-1])
#### 18. Что такое словарь в Python?
Словарь Python — это один из поддерживаемых типов данных. Это неупорядоченная коллекция элементов. Элементы в словарях хранятся в виде пар ключ-значение. Словари индексируются по ключам. Тип данных представлен в виде {}.

#Пример словаря
dictionary = {'key' : 'value'}
#### 19. Как получить доступ к значениям в словаре?
Вы можете получить доступ к значениям в словаре, индексируя их с помощью ключа. Индексация представлена в виде [].

#Доступ к словарю
dictionary = {'key' : 'value'}
print(dictionary['key'])
#### 20. Как получить список всех ключей в словаре?
Можно использовать атрибут, который есть у словаря — keys().

dictionary = {'key' : 'value', 'key1': : 'value1'}
print(dictionary.keys())
#### 21. В чем разница между списком и кортежем?
Разница между списком и кортежем заключается в том, что список является изменяемым, а кортеж — нет. Кортеж может быть хэширован, например, в качестве ключа для словарей. Список определяется с помощью [], а кортеж — с помощью () .

#Пример списка и кортежа
#Список
list_ex = [1,2,'test']
#Список изменяем
list_ex[0] = 100
#Кортеж
tuple_ex = (1,2,'test)
#Кортеж неизменяем
tuple_ex[0] = 100 #Вернет ошибку
#### 22. Что такое итераторы в Python?
В Python итераторы используются для итерации группы элементов, контейнеров, таких как список или строка. Под итерацией подразумевается, что что-то может быть зациклено с помощью оператора.

#### 23. Что делает [:: -1}?
[:: -1] используется для обратного порядка любого итерируемого объекта.

#Пример печати с конца
string = 'this is a string'
print(string[::-1])
#### 24. Как можно использовать тернарные операторы в Python?
Тернарный оператор — это оператор, который используется для отображения условных операторов. Он состоит из истинных или ложных значений с утверждением, которое нужно проверить.

#Пример тернарного оператора
a = 1
#Значения true
if a < 1:
   print('Less')
#Если не выполнилось предыдущее значение
else:
   print('More')
#### 25. Как работает break?
Оператор break позволяет завершить цикл, когда выполняется некоторое условие, и управление передается следующему оператору.

#Пример break
for i in range(5):
   if i < 3:
      print(i)
   else:
      break
#### 26. Каков смысл оператора pass в Python?
Оператор pass в Python используется, когда выражение требуется синтаксически, но вы не хотите, чтобы какая-либо команда или код выполнялись.

#Пример pass
for i in range(10):
   if i%2 == 0:
      print(i)
   else:
      pass
#### 27. Что такое функция map в Python?
map() — это функция, которая принимает другую в качестве аргумента, а затем применяет её ко всем элементам итератора, передаваемым ей в качестве другого аргумента. Функция вернет объект map, поэтому нам нужно преобразовать его в объект списка.

#Пример функции map
def number_exponential(num):
   return num**2
number_list = [2,3,4,5]
print(list(map(number_exponential, number_list)))
#### 28. Что такое функция enumerate в Python?
Метод enumerate() добавляет счетчик к итерируемому и возвращает его в виде объекта перечисления (enumerate). Объект будет состоять из счетчика и итерационных значений.

#Пример enumerate
iter_example = ['test', 'test2', 'test3']
for idx, val in enumerate(iter_example):
   print(idx)
   print(val)
#### 29. Что такое абстракции у словаря и списка в Python?
Они представляют собой синтаксические конструкции, облегчающие создание словаря или списка на основе существующих итеруемых. Создание происходит циклом внутри самого объекта.

#Абстракция словаря
dict_comprehension = {key:val for key, val in emumerate('sample')}
print(dict_comprehension)
#Абстракция списка
list_comprehension = [i for i in range(5)]
print(list_comprehension)
#### 30. Что такое slicing в Python?
Slicing (отсечение) — это механизм выбора диапазона элементов из таких типов последовательностей, как список, кортеж, строки и т.д. Такое отсечение выполняется методом индексации.

#Пример отсечения
list_example = [1,2,3,4,'test','test2']
print(list_example[1:4])
#### 31. Каков смысл not в операторе?
Операторы — это специальные функции. Они принимают одно или несколько значений и дают соответствующий результат. not вернет обратное логическое значение.

print(not 1 == 2)
#### 32. Каков смысл // в python?
Это оператор целочисленного деления, который используется для деления двух операндов с результатом, показывающим только цифры перед десятичной точкой.

print(5//2)
#### 33. Как добавить новое значение в объект списка?
Это можно сделать с помощью атрибута append(), который есть у списка. При передачи какого-то значения в этот атрибут, оно будет помещено в конец последовательности.

list_example = [1,2,3,4,5]
list_example.append(6)
print(list_example)
#### 34. Что такое поверхностная копия?
Поверхностная копия используется при создании нового типа экземпляра и сохраняет значения, скопированные в новом. Также она используется для копирования ссылочных указателей. Это означает, что когда мы копируем объект в другую переменную, он будет привязан.

#Пример поверхностной копии
list_example = [1,2,3,4,5]
another_list = list_example
another_list[0] = 100
print(list_example)
#### 35. Что такое глубокая копия?
Глубокая копия используется для хранения значений, которые уже скопированы. Глубокая копия не копирует ссылочные указатели на объекты. Она создает ссылку на объект, и новый объект, на который указывает другой, сохраняется. В отличие от неглубокой копии, изменения, внесенные в исходную копию, не повлияют ни на одну другую копию, использующую объект. Это значит, что они не привязаны.

#Пример глубокой копии
list_example = [1,2,3,4,5]
#Создание глубокой копии с помощью атрибута .copy
another_list = list_example.copy()
another_list[0] = 100
print(list_example)
#### 36. Как создать пустой класс в Python?
Пустой класс — это класс, который не имеет никакого кода, определенного в его блоке. Он может быть создан с помощью ключевого слова pass. Однако объекты этого класса можно создать и вне самого класса. В Python команда pass ничего не делает при ее выполнении, это null.

class sample:
    pass
test=sample()
test.name="test1"
print(test.name)
#### 37. Что означает ключевое слово self в Python?
Ключевое слово self используется в качестве первого параметра функции внутри класса, представляющего экземпляр класса. Объект или экземпляр класса автоматически передается методу, которому он принадлежит, и принимается в ключевом слове “self”. Пользователи могут использовать другое имя для первого параметра функции, которая указывает на объект класса, но рекомендуется использовать ключевое слово “self”, так как оно ближе к соглашению Python.

#### 38. Будет ли цикл do-while работать, если вы не закончите его точкой с запятой?
Это вопрос с подвохом! Во-первых, Python не поддерживает встроенный цикл do-while. Во-вторых, завершение циклов do-while является необходимостью для таких языков, как C++.

#### 39. Как преобразовать список в строку?
В этом случае мы могли бы использовать атрибут .join() из строкового объекта. Здесь мы передали объект списка в атрибут:

list_example = ['apple', 'grape', 'orange']
print(' '.join(list_example))
#### 40. Что такое оператор членства?
Это оператор, который может подтвердить, является ли значение членом в другом объекте. Операторы членства бывают “in” и “not in”.

#Пример операторов членства
print('me' in 'membership')
print('mes' not in 'membership')
#### 41. Что такое операторы тождественности в Python?
Они показывают нам, тождественны ли два значения. Операторы — “is” и “is not”.

#Пример операторов тождественности
print(1 is '1')
print(2 is not '2')
#### 42. Как обрабатывать входные данные в Python?
Для получения входных данных от пользователя можно использовать функцию input(). Она будет принимать входные данные от пользователя и возвращать их в строковый объект.

test = input('input a number: ')
print(test)
#### 43. Что делает функция zip()?
Она вернет итератор кортежей, сформирует n-пару значений из перечисляемых, передаваемых функции. n — это число итерируемых, которые передают функции.

#Пример функции Zip
print(list(zip([1,2,3], ['apple', 'grape', 'orange'], ['x', 2, True])))
for num, fruit, thing in zip([1,2,3], ['apple', 'grape', 'orange'], ['x', 2, True]):
    print(num)
    print(fruit)
    print(thing)
#### 44. В чем разница между тем, когда функция range() принимает один аргумент, два и три?
Когда мы передаем только один аргумент, функция принимает его в качестве стоп-значения. Здесь начальное значение равно 0, а шаговое +1. Итерация с диапазоном всегда будет останавливаться на единицу перед стоп-значением.

for i in range(5):
   print(i)
Когда мы передаем два аргумента, первый из них является начальным значением, а второй — стоп значением.

for i in range(1,5):
   print(i)
Используя три аргумента, первый аргумент является начальным, второй — стоп, а третий — значением шага.

for i in range(1,10,2):
   print(i)
#### 45. Напишите лучший код для перестановки двух чисел местами.
Вы можете выполнить перестановку с помощью одной строки.

a = 1
b = 2
#Перестановка чисел
a, b = b, a
#### 46. Как можно объявить несколько назначений в одной строке кода?
Есть два способа это сделать. Первый — это отдельное объявление переменной в той же строке:

a, b, c = 1,2,3
Другой способ — объявить переменную в той же строке только с одним значением:

a=b=c=1
#### 47. Как вырваться из бесконечного цикла?
Чтобы прервать процесс, нужно нажать Ctrl+C.
#### 
#### 48. Что делает оператор with в Python?
Оператор with в Python гарантирует, что код очистки выполняется при работе с неуправляемыми ресурсами путем инкапсуляции общих задач подготовки и очистки. Он может быть использован, чтобы открыть файл, сделать что-то, а затем автоматически закрыть его. Также он может пригодиться для открытия соединения с базой данных, выполнения некоторой обработки, а затем автоматического закрытия, чтобы гарантировать, что ресурсы закрыты и доступны для других. with выполнит очистку ресурсов, даже если выдается исключение.

#Пример оператора with
with open('database.txt') as data:
    print(data)
#### 49. Когда выполняется except, в блоке try-except?
Блок try-except обычно используется, когда мы хотим что-то выполнить, если возникли ошибки. except выполняется, когда код в блоке try вызвал ошибки.

a = (1,2,3)
try:
   a[0] = 2
except:
   print('There is an error')
#### 50. Где вы будете использовать while вместо for?
Для простого повторяющегося цикла, либо тогда, когда не нужно перебирать список элементов, например записи базы данных и символы в строке.

#### 51. Что такое модули Python?
Это независимые скрипты Python с расширением .py, которые можно повторно использовать в других кодах Python или скриптах с помощью оператора import. Модули могут состоять из функций, классов и переменных, а также некоторого выполняемого кода. Они помогают не только упорядочить коды Python, но и сделать их менее сложными и более эффективными.

import #имя модуля
#### 52. Что такое PYTHONPATH?
PYTHONPATH — это переменная окружения, которая при импорте проверяется на наличие импортированных модулей в различных каталогах. Интерпретатор использует её, чтобы определить, какой модуль следует загрузить.

#### 53. Назовите пример режимов обработки файлов с помощью Python?
Существуют следующие режимы:

Режим только для чтения (‘r’): открыть файл для чтения. Это режим по умолчанию.
Режим только для записи (‘w’): открыть файл для записи. Если файл содержит данные, они будут потеряны. Создается новый файл.
Режим чтения-записи (‘rw’): открыть файл для чтения, режим записи. Это режим обновления.
Режим добавления (‘a’): открыть для записи, добавить в конец файла, если файл существует.
#### 54. Что такое pickling и unpickling?
Модуль pickle принимает любой объект Python, преобразует его в строковое представление и сохраняет в файл с помощью функции dump, такой процесс называется pickling. Процесс извлечения исходных объектов Python из сохраненного строкового представления называется unpickling.

import pickle
a = 1
#Процесс pickling
pickle.dump(a, open('file.sav', 'wb'))
#Процесс unpickling
file = pickle.load(open('file.sav', 'rb'))
#### 55. Являются ли массивы Python NumPy лучше списков?
Мы используем массивы Python NumPy вместо списка по следующим трем причинам:

1. меньший объем памяти;

2. быстрее;

3. удобнее.

#### 56. Как вычислять процентили с помощью NumPy?
Медиана — это 50 процентиль по определению. 25 процентиль указывает, что 25% наблюдаемых меньше числа в процентиле, то есть n процентов наблюдаемых значений меньше значения в процентиле n.

Мы можем вычислить его с помощью NumPy, используя следующий код:

import numpy as np
a = np.array([i for i in range(100)])
p = np.percentile(a, 50) #Возвращает 50-ый перцентиль - медиану
print(p)
#### 57. Как получить текущий рабочий каталог с помощью Python?
Работая с Python, вам может понадобиться читать и записывать файлы из различных каталогов. Чтобы узнать, в каком вы сейчас работаете, можно использовать метод getcwd() из модуля os:

import os
os.getcwd()
#### 58. Что вы видите снизу? Что произойдет, если мы выполним этот код?
a = '1'
b = '2'
c = '3's = a + ‘[‘ + b + ‘:’ + c + ‘]’
print(s)
Это конкатенация строк. Если даже одна из переменных не является строкой, она вызовет ошибку типа (TypeError). Выполнив этот код, мы получим результат конкатенации.

#### 59. Как бы вы произвели рандомизацию содержимого списка на месте?
Мы можем воспользоваться функцией shuffle() из модуля random:

from random import shuffle
list_example = [1,2,3,4,5,6,7,8]
shuffle(list_example)
#### 60. Что такое приведение в Python?
Приведение — это процесс преобразования значения переменной из одного типа в другой. В Python это можно сделать с помощью таких функций, как list(), int (), float() и str(). Примером может служить преобразование строки в целочисленный объект:

a = '1'
b = int(a)
#### 61. Объясните ошибку
from numpy imprt stdev
ImportError Traceback (most recent call last)
<ipython-input-26-685c12521ed4> in <module>
----> 1 from numpy import stdev
ImportError: cannot import name 'stdev' from 'numpy'
В приведенном выше коде мы пытаемся импортировать несуществующую функцию из модуля numpy. В этом причина.

#### 62. Как можно удалить переменные в Python?
Для удаления переменной мы можем использовать функцию del(). Считается хорошей практикой, убрать что-то лишнее, что не используется.

a = 1
del a
#### 63. Что такое pandas в Python?
Pandas — это пакет Python, предоставляющий быстрые, гибкие и функциональные структуры данных, предназначенные для того, чтобы сделать работу с “реляционными” или “помеченными” данными простой и интуитивно понятной. Он призван стать фундаментальным строительным блоком высокого уровня для практического анализа реальных данных в Python.

#### 64. В чем разница между методами append() и extend()?
Они используются для добавления элементов в конец списка.

append(элемент): добавляет элемент в конец списка;
extend(другой список): добавляет элементы другого списка в конец первого.
#### 65. Как получить текущую версию Python?
Мы можем узнать текущую версию Python с помощью sys.version:

import sys
sys.version
#### 66. Что значит *args, **kwargs? И зачем нам их использовать?
Мы используем *args, когда неуверены, сколько аргументов будет передано функции, или если хотим передать сохраненный список или кортеж аргументов функции. **kwargs используется, когда мы не знаем, сколько аргументов ключевых слов будет передано, а также он может быть использован для передачи значений словаря в качестве аргументов ключевых слов. Идентификаторы args и kwargs необязательны, вы можете изменить их на другие, типа *другой **пример, но лучше использовать имя по умолчанию.

#Пример *args
def sample(*args):
    print(args)
sample('time', 1, True)
#Пример **kwargs
def sample(**kwargs):
    print(kwargs)
sample(a = 'time', b = 1)
#### 67. Что за функции help() и dir() в Python?
Функция help() отображает строку документации и справку для своего аргумента.

import numpy
help(numpy.array)
Функция dir() отображает все элементы объекта (любого вида).

import numpy
dir(numpy.array)
#### 68. Что означает одинарное и двойное подчеркивание перед именем объекта?
Одиночное подчеркивание — имена в классе с подчеркиванием перед ними просто указывают другим программистам, что атрибут или метод предназначен для закрытого использования, однако с самим именем ничего особенного не делается.

Двойное подчеркивание (искажение имени) — любой идентификатор вида __spam (не менее двух ведущих подчеркиваний, не более одного завершающего) заменяется на _имякласса__spam, где имя класса — это текущее спрятанное имя с подчеркиванием перед ним. Это искажение выполняется без учета синтаксической позиции идентификатора, поэтому его можно использовать для определения экземпляра закрытого класса и его переменных, методов, а также глобальных и других переменных, хранящихся в экземплярах, частных для этого класса в экземплярах других.

#### 69. Каков результат нижеприведенного запроса?
ss = “Python Programming!”
print(ss[5])
Ответ: ‘n’

#### 70. Напишите программу на Python, чтобы создать треугольник из звезд
def star_triangle(r):
   for x in range(r):
      print(' '*(r-x-1)+'*'*(2*x+1))
star_triangle(7)

#### 71. Что плохого в следующем коде:
counter = 0
def increment():
   counter += 1
increment()
В Python нет объявлений переменных, поэтому он должен сам определить их область действия. Если внутри функции имеется обращение к переменной, то она считается локальной. Переменная counter выше является глобальной, поэтому код выбрасывает ошибку.

#### 72. Как разделить строку на список?
<details>
<summary>Ответ</summary>
Можно использовать атрибут split(). Он принимает разделитель в качестве аргумента и возвращает список, состоящий из результатов разделения строки на его основе. По умолчанию в качестве разделителя используется пробел.

Синтаксис следующий:

text = 'hello again world !'
text.split(' ')
</details>

#### 73. Что такое палином? Напишите программу на Python, чтобы проверить, является ли последовательность, которую вы вводите, палиндромом
<details>
<summary>Ответ</summary>
Вопрос на знание базовых алгоритмов.

_Палиндром_ - это слово или фраза, которые одинаково читаются слева направо и справа налево. Самый известный пример: "а роза упала на лапу Азора".
  
a = input("enter the sequence: ")
b =a [::-1]
if a == b:
   print("Palindrome")
else:
   print("Not a Palindrome")
</details>

#### 74. Что такое генератор?

<details>
<summary>Ответ</summary>
Генератор Python создает последовательность значений для итерации, часто с помощью функции. Мы определяем функцию с помощью yield , которая используется для получения значения по одному, а затем используем цикл for для итерации.

def squares(n):
    i=1
    while(i<=n):
        yield i**2
        i+=1
for i in squares(7):
    print(i)
</details>

#### 75. Напишите программу на Python для проверки, является ли число простым

<details>
<summary>Ответ</summary>
Вопрос на знание базовых алгоритмов.

_Простое число_ - натуральное число, имеющее ровно два различных натуральных делителя. Другими словами, натуральное число является простым, если оно отлично от и делится без остатка только на 1 и на само себя.

a = int(input("Enter a number"))     
if a > 1:
    for x in range(2, a):
        if(a % x) == 0:
            print("Not prime")
            break
    else:
        print("Prime")
else:
    print("Not prime")
</details>

#### 78. Что такое распаковка кортежа?

<details>
<summary>Ответ</summary> 
_Распаковка кортежа_ - это процесс распаковки его значений и их ввода в несколько различных переменных.

tup = (1,2,3)
#Процесс распаковки кортежа
a,b,c = tup
</details>

#### 80. Является ли функция допустимой, если она не имеет оператора return?

<details>
<summary>Ответ</summary> 
Ключевое слово _return_ необязательно обозначает конец функции, оно просто завершает ее, если присутствует. Обычно блок кода помечает функцию, и там, где заканчивается блок, заканчивается и тело функции.
  
При этом, функция может ничего не возвращать, и _return_ может отсутствовать. Функция, которая ничего не возвращает, возвращает объект None.
</details>



