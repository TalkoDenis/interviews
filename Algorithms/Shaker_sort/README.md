### Шейкерная сортировка

_Сортировка перемешиванием (шейкерная сортировка, cocktail sort, shaker sort)_ – это усовершенствованная разновидность сортировки пузырьком, при которой сортировка производиться в двух направлениях, меняя направление при каждом проходе.

Проанализировав алгоритм пузырьковой сортировки, можно заметить следующее:

если при обходе части массива не было обменов элементов, то эту часть можно исключить, так как она уже отсортирована;

при проходе от конца массива к началу минимальное значение сдвигается на первую позицию, при этом максимальный элемент перемещается только на один индекс вправо.

#### Алгоритм

Данный тип сортировки представляет собой улучшенный вариант пузырькового способа упорядочивания данных. Он является двунаправленным. Принцип данной сотрировки состоит в том, что проход делается сначала в одну сторону массива, сравнивая и сортируя по очереди соседние два числа массива, и когда алгоритм доходит до конца массива, наиболее крупное число оказывается в правой его части.

В пузырьковой сортировке происходит возврат в начало массива и все повторялось заново. В этом методе возврат не производится, а происходит переход влево, попарно сравнивая соседние элементы. Результатом прохода в левую сторону станет минимальное число, которое выводится в начало массива. Затем снова начинается движение вправо, сортируя и выводя предпоследнее число результирующего массива. Дойдя до конца, направление сортировки снова меняется, и процесс продолжает выполнять действия до тех пор, пока массив не будет отсортирован.

#### Время сортировки
Как и в случае с сортировкой пузырьком, при самом худшем сценарии затраты времени будут равны O(n²), где n - количество элементов списка. Но всё же этот алгоритм чуть совершеннее и работает несколько быстрее.

<details>
<summary>Реализация на Python</summary>

```
def shaker_sort(nums): 
    # Определяем начальный (левый) и конечный (правый) элементы
    left = 0
    right = len(nums) - 1
    while left <= right:
        # Проходимся от левого до правого элемента с шагом один
        for i in range(left, right, 1):
            if nums[i] > nums[i + 1]:
                nums[i], nums[i + 1] = nums[i + 1], nums[i]
        right -= 1
        # Проходимся от правого до левого элемента с шагом минус один!
        for i in range(right, left, -1):
            if nums[i - 1] > nums[i]:
                nums[i], nums[i - 1] = nums[i - 1], nums[i]
        left += 1
    return nums
```

</details>

<details>
<summary>Реализация на Ruby</summary>

```
def shaker_sort(nums) 
    # Определяем начальный (левый) и конечный (правый) элементы
    left = 0
    right = nums.size - 1
    while left <= right
        # Проходимся от левого до правого элемента с шагом один
        (left...right).each do |i|
            if nums[i] > nums[i + 1]
                nums[i], nums[i + 1] = nums[i + 1], nums[i]
            end
        right -= 1
        end
        # Проходимся от правого до левого элемента с шагом минус один!
        (right).downto(left).each do |i|
            if nums[i - 1] > nums[i]
                nums[i], nums[i - 1] = nums[i - 1], nums[i]
            end
        left += 1
        end
    end
    return nums
end
```

</details>
