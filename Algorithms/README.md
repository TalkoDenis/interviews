# Алгоритмы

Собрал немного материалов по алгоритмам. Знать их так или иначе нужно. Плюс иногда их спрашивают на собеседованиях. Постарался собрать материал от самого простого к сложному.

Реализация на Python и Ruby.

### Пузырьковая сортировка

_Пузырьковая сортировка (или иногда называют Сортировка пузырьком, bubble sort)_ - один из самых известных алгоритмов сортировки. Здесь последовательно сравниваются значения соседних элементов, и числа меняются местами, если предыдущее оказывается больше последующего. Таким образом элементы с большими значениями оказываются в конце списка, а с меньшими остаются в начале

#### Алгоритм
Сначала сравниваются первые два элемента списка. Если первый элемент больше второго, они меняются местами. Если элементы уже в нужном порядке, они остаются как есть. Затем необходимо перейти к следующей паре элементов, сравнить их значения и поменяем местами при необходимости. Этот процесс продолжается до последней пары элементов в списке.

При достижении конца списка процесс повторяется заново для каждого элемента. Это крайне неэффективно, если в массиве нужно сделать, например, только один обмен. Алгоритм повторяется n² раз, даже если список уже отсортирован.

Для оптимизации алгоритма нужно знать, когда его остановить, то есть когда список отсортирован.

Чтобы остановить алгоритм по окончанию сортировки, нужно ввести переменную-флаг. Когда значения меняются местами, флаг устанавливается в значение True, чтобы повторить процесс сортировки. Если перестановок не произошло, флаг остаётся False и алгоритм останавливается.

Алгоритм работает в цикле while и прерывается, когда элементы ни разу не меняются местами. Вначале swapped присваивается значение True, чтобы алгоритм запустился хотя бы один раз.


#### Время сортировки
Если взять самый худший случай (изначально список отсортирован по убыванию), затраты времени будут равны O(n²), где n - количество элементов списка.

Этот алгоритм считается учебным и почти не применяется на практике из-за низкой эффективности: он медленно работает на тестах, в которых маленькие элементы стоят в конце массива. Однако на нём основаны многие другие методы, например, _шейкерная сортировка_ и _сортировка расчёской_. Об этих алгоритмах будет написано далее.


<details>
<summary>Реализация на Python</summary>

```
def bubble_sort(nums):  
    # swapped установлен в True, чтобы цикл запустился хотя бы один раз
    swapped = True
    while swapped:
        swapped = False
        for i in range(len(nums) - 1):
            if nums[i] > nums[i + 1]:
                # Элементы меняются местами
                nums[i], nums[i + 1] = nums[i + 1], nums[i]
                # Устанавливаем swapped в True для следующей итерации
                swapped = True
    return nums
```

</details>

<details>
<summary>Реализация на Ruby</summary>

```
def bubble_sort(nums)
    # swapped установлен в true, чтобы цикл запустился хотя бы один раз
    swapped = true
    # определяется размер списка
    nums_length = nums.size
    while swapped
        swapped = false
        (nums_length - 1).times do |i|
            if nums[i] > nums[i + 1]
                # Элементы меняются местами
                nums[i], nums[i + 1] = nums[i + 1], nums[i]
                # Устанавливаем swapped в True для следующей итерации
                swapped = true
            end
        end
    end
    return nums
end
```

</details>






https://tproger.ru/translations/sorting-algorithms-in-python



### Шейкерная сортировка

_Сортировка перемешиванием (шейкерная сортировка, cocktail sort, shaker sort)_ – это усовершенствованная разновидность сортировки пузырьком, при которой сортировка производиться в двух направлениях, меняя направление при каждом проходе.

Проанализировав алгоритм пузырьковой сортировки, можно заметить следующее:

если при обходе части массива не было обменов элементов, то эту часть можно исключить, так как она уже отсортирована;

при проходе от конца массива к началу минимальное значение сдвигается на первую позицию, при этом максимальный элемент перемещается только на один индекс вправо.

#### Алгоритм

Данный тип сортировки представляет собой улучшенный вариант пузырькового способа упорядочивания данных. Он является двунаправленным. Принцип данной сотрировки состоит в том, что проход делается сначала в одну сторону массива, сравнивая и сортируя по очереди соседние два числа массива, и когда алгоритм доходит до конца массива, наиболее крупное число оказывается в правой его части.

В пузырьковой сортировке происходит возврат в начало массива и все повторялось заново. В этом методе возврат не производится, а происходит переход влево, попарно сравнивая соседние элементы. Результатом прохода в левую сторону станет минимальное число, которое выводится в начало массива. Затем снова начинается движение вправо, сортируя и выводя предпоследнее число результирующего массива. Дойдя до конца, направление сортировки снова меняется, и процесс продолжает выполнять действия до тех пор, пока массив не будет отсортирован.

#### Время сортировки
Как и в случае с сортировкой пузырьком, при самом худшем сценарии затраты времени будут равны O(n²), где n - количество элементов списка. Но всё же этот алгоритм чуть совершеннее и работает несколько быстрее.

<details>
<summary>Реализация на Python</summary>

```
def shaker_sort(nums): 
    # Определяем начальный (левый) и конечный (правый) элементы
    left = 0
    right = len(nums) - 1
    while left <= right:
        # Проходимся от левого до правого элемента с шагом один
        for i in range(left, right, 1):
            if nums[i] > nums[i + 1]:
                nums[i], nums[i + 1] = nums[i + 1], nums[i]
        right -= 1
        # Проходимся от правого до левого элемента с шагом минус один!
        for i in range(right, left, -1):
            if nums[i - 1] > nums[i]:
                nums[i], nums[i - 1] = nums[i - 1], nums[i]
        left += 1
    return nums
```

</details>

<details>
<summary>Реализация на Ruby</summary>

```
def shaker_sort(nums) 
    # Определяем начальный (левый) и конечный (правый) элементы
    left = 0
    right = nums.size - 1
    while left <= right
        # Проходимся от левого до правого элемента с шагом один
        (left...right).each do |i|
            if nums[i] > nums[i + 1]
                nums[i], nums[i + 1] = nums[i + 1], nums[i]
            end
        right -= 1
        end
        # Проходимся от правого до левого элемента с шагом минус один!
        (right).downto(left).each do |i|
            if nums[i - 1] > nums[i]
                nums[i], nums[i - 1] = nums[i - 1], nums[i]
            end
        left += 1
        end
    end
    return nums
end
```

</details>

### Сортировка расчёской

_Сортировка расчёской (comb sort)_ - улучшение сортировки пузырьком. Основная идея состоит в том, чтобы «устранить» элементы с небольшими значения в конце массива, которые замедляют работу алгоритма. Если при пузырьковой и шейкерной сортировках при переборе массива сравниваются соседние элементы, то при «расчёсывании» сначала берётся достаточно большое расстояние между сравниваемыми значениями, а потом оно сужается вплоть до минимального.

Первоначальный разрыв нужно выбирать не случайным образом, а с учётом специальной величины - фактора уменьшения, оптимальное значение которого равно 1,247. Сначала расстояние между элементами будет равняться размеру массива, поделённому на 1,247. На каждом последующем шаге расстояние будет снова делиться на фактор уменьшения, и так до окончания работы алгоритма.

#### Алгоритм

На первом шаге находится длина массива (например, массив состоит из 10 элементов), делится на 1,247 и округляется. После округления получилось число 8. Теперь проходится первый цикл пузырьковой сортировки, только сравниваются не 1 и 2, 2 и 3 элементы, а сразу 1 и 8, 2 и 9, 3 и 10. Это отправит самые большие числа, если они есть в начале, в самый конец. Всего на первом шаге будет три сравнения.

На втором шаге берётся число 8 из предыдущего этапа и снова делится на 1,247, получая число 6. Теперь снова проходится массив и сравниваются элементы: 1 и 6, 2 и 7, 3 и 8, 4 и 9, 5 и 10.

Уже получилось 5 перестановок и снова крупные числа оказались ближе к концу массива.

Таким образом уменьшается размер шага до тех пор, пока он не станет меньше единицы - к этому моменту массив будет полностью отсортирован.

Почему это лучше пузырьковой сортировки, ведь алгоритм выглядит сложнее и в конце мы всё равно сравниваем соседние элементы?

"Расчёска" лучше пузырьковой сортировки, потому что в ней намного меньше операций перестановки. Именно перестановка занимает основное время процессора. В самом худшем случае алгоритм сортировки расчёской будет работать так же, как и пузырьковая, а в среднем — алгоритм работает быстрее пузырьковой.


<details>
<summary>Реализация на Python</summary>

```

def comb_sort(nums):
    # Получаем длину массива
    l = len(nums)
    # Оптимальное число для вычисления шага сравнения
    factor = 1.247
    # Получаем точный шаг сравнения
    gap_factor = l / factor
    while gap_factor > 1:
        gap = round(gap_factor)
        for i in range(l - gap):
            j = i + gap
            if nums[i] > nums[j]:
                nums[i], nums[j] = nums[j], nums[i]
        gap_factor = gap_factor / factor
    return nums

```

</details>

<details>
<summary>Реализация на Ruby</summary>

```

def comb_sort(nums)
  # получаем длину массива
  l = nums.size
  # оптимальное число для вычисления шага сравнения
  factor = 1.247
  # получаем точный шаг сравнения
  gap_factor = l / factor
  # пока шаг больше единицы
  while gap_factor > 1
    gap = gap_factor.round
    (0..(l - gap - 1)).each do |i|
      j = i + gap
      if nums[i] > nums[j]
        nums[i], nums[j] = nums[j], nums[i]
      end
    end
    gap_factor = gap_factor / factor
  end
  return nums
end

```

</details>

### Сортировка вставками

_Сортировка вставками (insertion sort)_ - это алгоритм сортировка, в котором все элементы массива просматриваются поочередно, при этом каждый элемент размещается в соответственное место среди ранее упорядоченных значений.

#### Алгоритм

Алгоритм работы сортировки вставками заключается в следующем:

В начале работы упорядоченная часть пуста.

В отсортированную область добавляется первый элемент массива из неупорядоченных данных.

Цикл переходит к следующему элементу в не отсортированных данных, и находит ему правильную позицию в отсортированной части массива, тем самым мы расширяем область упорядоченных данных.

Предыдущий шаг повторяется для всех оставшихся элементов.


<details>
<summary>Реализация на Python</summary>

```

def insertion_sort(nums): 
    length = len(nums) 
    for i in range(1, length):
        key = nums[i]
        j = i
        while (j - 1 >= 0) and (nums[j - 1] > key):
            nums[j - 1], nums[j] = nums[j], nums[j - 1]
            j = j - 1
        nums[j] = key
    return nums

```

</details>

<details>
<summary>Реализация на Ruby</summary>

```

def insertion_sort(nums) 
    length = nums.size 
    length.times do |i|
        key = nums[i]
        j = i
        while (j - 1 >= 0) and (nums[j - 1] > key)
            nums[j - 1], nums[j] = nums[j], nums[j - 1]
            j = j - 1
        end
        nums[j] = key
    end
    return nums
end

```



