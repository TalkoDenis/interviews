# Алгоритмы

Собрал немного материалов по алгоритмам. Знать их так или иначе нужно. Плюс иногда их спрашивают на собеседованиях. Постарался собрать материал от самого простого к сложному.

Реализация на Python и Ruby.

### Пузырьковая сортировка

_Пузырьковая сортировка (или иногда называют Сортировка пузырьком, bubble sort)_ - один из самых известных алгоритмов сортировки. Здесь последовательно сравниваются значения соседних элементов, и числа меняются местами, если предыдущее оказывается больше последующего. Таким образом элементы с большими значениями оказываются в конце списка, а с меньшими остаются в начале

#### Алгоритм
Сначала сравниваются первые два элемента списка. Если первый элемент больше второго, они меняются местами. Если элементы уже в нужном порядке, они остаются как есть. Затем необходимо перейти к следующей паре элементов, сравнить их значения и поменяем местами при необходимости. Этот процесс продолжается до последней пары элементов в списке.

При достижении конца списка процесс повторяется заново для каждого элемента. Это крайне неэффективно, если в массиве нужно сделать, например, только один обмен. Алгоритм повторяется n² раз, даже если список уже отсортирован.

Для оптимизации алгоритма нужно знать, когда его остановить, то есть когда список отсортирован.

Чтобы остановить алгоритм по окончанию сортировки, нужно ввести переменную-флаг. Когда значения меняются местами, флаг устанавливается в значение True, чтобы повторить процесс сортировки. Если перестановок не произошло, флаг остаётся False и алгоритм останавливается.

Алгоритм работает в цикле while и прерывается, когда элементы ни разу не меняются местами. Вначале swapped присваивается значение True, чтобы алгоритм запустился хотя бы один раз.


#### Время сортировки
Если взять самый худший случай (изначально список отсортирован по убыванию), затраты времени будут равны O(n²), где n - количество элементов списка.

Этот алгоритм считается учебным и почти не применяется на практике из-за низкой эффективности: он медленно работает на тестах, в которых маленькие элементы стоят в конце массива. Однако на нём основаны многие другие методы, например, _шейкерная сортировка_ и _сортировка расчёской_. Об этих алгоритмах будет написано далее.


<details>
<summary>Реализация на Python</summary>

```
def bubble_sort(nums):  
    # swapped установлен в True, чтобы цикл запустился хотя бы один раз
    swapped = True
    while swapped:
        swapped = False
        for i in range(len(nums) - 1):
            if nums[i] > nums[i + 1]:
                # Элементы меняются местами
                nums[i], nums[i + 1] = nums[i + 1], nums[i]
                # Устанавливаем swapped в True для следующей итерации
                swapped = True
    return nums
```

</details>

<details>
<summary>Реализация на Ruby</summary>

```
def bubble_sort(nums)
    # swapped установлен в true, чтобы цикл запустился хотя бы один раз
    swapped = true
    # определяется размер списка
    nums_length = nums.size
    while swapped
        swapped = false
        (nums_length - 1).times do |i|
            if nums[i] > nums[i + 1]
                # Элементы меняются местами
                nums[i], nums[i + 1] = nums[i + 1], nums[i]
                # Устанавливаем swapped в True для следующей итерации
                swapped = true
            end
        end
    end
    return nums
end
```

</details>

### Шейкерная сортировка

_Сортировка перемешиванием (шейкерная сортировка, cocktail sort, shaker sort)_ – это усовершенствованная разновидность сортировки пузырьком, при которой сортировка производиться в двух направлениях, меняя направление при каждом проходе.

Проанализировав алгоритм пузырьковой сортировки, можно заметить следующее:

если при обходе части массива не было обменов элементов, то эту часть можно исключить, так как она уже отсортирована;

при проходе от конца массива к началу минимальное значение сдвигается на первую позицию, при этом максимальный элемент перемещается только на один индекс вправо.

#### Алгоритм

Данный тип сортировки представляет собой улучшенный вариант пузырькового способа упорядочивания данных. Он является двунаправленным. Принцип данной сотрировки состоит в том, что проход делается сначала в одну сторону массива, сравнивая и сортируя по очереди соседние два числа массива, и когда алгоритм доходит до конца массива, наиболее крупное число оказывается в правой его части.

В пузырьковой сортировке происходит возврат в начало массива и все повторялось заново. В этом методе возврат не производится, а происходит переход влево, попарно сравнивая соседние элементы. Результатом прохода в левую сторону станет минимальное число, которое выводится в начало массива. Затем снова начинается движение вправо, сортируя и выводя предпоследнее число результирующего массива. Дойдя до конца, направление сортировки снова меняется, и процесс продолжает выполнять действия до тех пор, пока массив не будет отсортирован.

#### Время сортировки
Как и в случае с сортировкой пузырьком, при самом худшем сценарии затраты времени будут равны O(n²), где n - количество элементов списка. Но всё же этот алгоритм чуть совершеннее и работает несколько быстрее.

<details>
<summary>Реализация на Python</summary>

```
def shaker_sort(nums): 
    # Определяем начальный (левый) и конечный (правый) элементы
    left = 0
    right = len(nums) - 1
    while left <= right:
        # Проходимся от левого до правого элемента с шагом один
        for i in range(left, right, 1):
            if nums[i] > nums[i + 1]:
                nums[i], nums[i + 1] = nums[i + 1], nums[i]
        right -= 1
        # Проходимся от правого до левого элемента с шагом минус один!
        for i in range(right, left, -1):
            if nums[i - 1] > nums[i]:
                nums[i], nums[i - 1] = nums[i - 1], nums[i]
        left += 1
    return nums
```

</details>

<details>
<summary>Реализация на Ruby</summary>

```
def shaker_sort(nums) 
    # Определяем начальный (левый) и конечный (правый) элементы
    left = 0
    right = nums.size - 1
    while left <= right
        # Проходимся от левого до правого элемента с шагом один
        (left...right).each do |i|
            if nums[i] > nums[i + 1]
                nums[i], nums[i + 1] = nums[i + 1], nums[i]
            end
        right -= 1
        end
        # Проходимся от правого до левого элемента с шагом минус один!
        (right).downto(left).each do |i|
            if nums[i - 1] > nums[i]
                nums[i], nums[i - 1] = nums[i - 1], nums[i]
            end
        left += 1
        end
    end
    return nums
end
```

</details>

### Сортировка расчёской

_Сортировка расчёской (comb sort)_ - улучшение сортировки пузырьком. Основная идея состоит в том, чтобы «устранить» элементы с небольшими значения в конце массива, которые замедляют работу алгоритма. Если при пузырьковой и шейкерной сортировках при переборе массива сравниваются соседние элементы, то при «расчёсывании» сначала берётся достаточно большое расстояние между сравниваемыми значениями, а потом оно сужается вплоть до минимального.

Первоначальный разрыв нужно выбирать не случайным образом, а с учётом специальной величины - фактора уменьшения, оптимальное значение которого равно 1,247. Сначала расстояние между элементами будет равняться размеру массива, поделённому на 1,247. На каждом последующем шаге расстояние будет снова делиться на фактор уменьшения, и так до окончания работы алгоритма.

#### Алгоритм

На первом шаге находится длина массива (например, массив состоит из 10 элементов), делится на 1,247 и округляется. После округления получилось число 8. Теперь проходится первый цикл пузырьковой сортировки, только сравниваются не 1 и 2, 2 и 3 элементы, а сразу 1 и 8, 2 и 9, 3 и 10. Это отправит самые большие числа, если они есть в начале, в самый конец. Всего на первом шаге будет три сравнения.

На втором шаге берётся число 8 из предыдущего этапа и снова делится на 1,247, получая число 6. Теперь снова проходится массив и сравниваются элементы: 1 и 6, 2 и 7, 3 и 8, 4 и 9, 5 и 10.

Уже получилось 5 перестановок и снова крупные числа оказались ближе к концу массива.

Таким образом уменьшается размер шага до тех пор, пока он не станет меньше единицы - к этому моменту массив будет полностью отсортирован.

Почему это лучше пузырьковой сортировки, ведь алгоритм выглядит сложнее и в конце мы всё равно сравниваем соседние элементы?

"Расчёска" лучше пузырьковой сортировки, потому что в ней намного меньше операций перестановки. Именно перестановка занимает основное время процессора. В самом худшем случае алгоритм сортировки расчёской будет работать так же, как и пузырьковая, а в среднем — алгоритм работает быстрее пузырьковой.


<details>
<summary>Реализация на Python</summary>

```

def comb_sort(nums):
    # Получаем длину массива
    l = len(nums)
    # Оптимальное число для вычисления шага сравнения
    factor = 1.247
    # Получаем точный шаг сравнения
    gap_factor = l / factor
    while gap_factor > 1:
        gap = round(gap_factor)
        for i in range(l - gap):
            j = i + gap
            if nums[i] > nums[j]:
                nums[i], nums[j] = nums[j], nums[i]
        gap_factor = gap_factor / factor
    return nums

```

</details>

<details>
<summary>Реализация на Ruby</summary>

```

def comb_sort(nums)
  # получаем длину массива
  l = nums.size
  # оптимальное число для вычисления шага сравнения
  factor = 1.247
  # получаем точный шаг сравнения
  gap_factor = l / factor
  # пока шаг больше единицы
  while gap_factor > 1
    gap = gap_factor.round
    (0..(l - gap - 1)).each do |i|
      j = i + gap
      if nums[i] > nums[j]
        nums[i], nums[j] = nums[j], nums[i]
      end
    end
    gap_factor = gap_factor / factor
  end
  return nums
end

```

</details>

### Сортировка вставками

_Сортировка вставками (insertion sort)_ - это алгоритм сортировка, в котором все элементы массива просматриваются поочередно, при этом каждый элемент размещается в соответственное место среди ранее упорядоченных значений.

#### Алгоритм

Алгоритм работы сортировки вставками заключается в следующем:

В начале работы упорядоченная часть пуста.

В отсортированную область добавляется первый элемент массива из неупорядоченных данных.

Цикл переходит к следующему элементу в не отсортированных данных, и находит ему правильную позицию в отсортированной части массива, тем самым мы расширяем область упорядоченных данных.

Предыдущий шаг повторяется для всех оставшихся элементов.

#### Время сортировки
Время сортировки вставками в среднем равно O(n²), где n — количество элементов списка.

<details>
<summary>Реализация на Python</summary>

```

def insertion_sort(nums): 
    length = len(nums) 
    for i in range(1, length):
        key = nums[i]
        j = i
        while (j - 1 >= 0) and (nums[j - 1] > key):
            nums[j - 1], nums[j] = nums[j], nums[j - 1]
            j = j - 1
        nums[j] = key
    return nums

```

</details>

<details>
<summary>Реализация на Ruby</summary>

```

def insertion_sort(nums) 
    length = nums.size 
    length.times do |i|
        key = nums[i]
        j = i
        while (j - 1 >= 0) and (nums[j - 1] > key)
            nums[j - 1], nums[j] = nums[j], nums[j - 1]
            j = j - 1
        end
        nums[j] = key
    end
    return nums
end

```

### Случайная сортировка

_Случайная сортировка (Bogosort)_ - один из самых неэффективных алгоритмов сортировки массивов. Рассматривать его стоит исключительно в учебных целях!

#### Алгоритм

Вначале массив проверяется на упорядоченность. Если элементы не отсортированы, то они перемешиваются случайным образом и снова проверяется, упорядочен ли массим. Операция повторяется до тех пор, пока массив не будет отсортирован. Когда-нибудь ведь должно сработать?

<details>
<summary>Реализация на Python</summary>

```
import random

# Метод проверки упорядоченности массива
def is_sorted(nums):
    length = len(nums)
    for i in range(0, length - 1):
        if(nums[i] > nums[i + 1]):
            return False
    return True

# Перемешивание массива в случайном порядке
def random_permutation(nums):
    length = len(nums)
    for i in range(0, length):
        rnd = random.randint(0, length - 1)
        # обмен элементов массива
        temp = nums[i]
        nums[i] = nums[rnd]
        nums[rnd] = temp

# Случайная сортировка
def bogo_sort(nums):
    while(not(is_sorted(nums))):
        random_permutation(nums)
    return nums
```

</details>

<details>
<summary>Реализация на Ruby</summary>

```

# Метод проверки упорядоченности массива
def sorted?(nums)
    length = nums.length
    (0..length - 2).each do |i|
      return false if nums[i] > nums[i + 1]
    end
    return true
end
  
# Перемешивание массива в случайном порядке
def random_permutation(nums)
    length = nums.length
    (0..length - 1).each do |i|
      rnd = rand(0..length - 1)
      # обмен элементов массива
      temp = nums[i]
      nums[i] = nums[rnd]
      nums[rnd] = temp
    end
end
  
# Случайная сортировка
def bogo_sort(nums)
    until sorted?(nums)
      random_permutation(nums)
    end
    nums
end

```

</details>

### Сортировка выборкой

Этот алгоритм сегментирует список на две части: отсортированную и неотсортированную. Наименьший элемент удаляется из второго списка и добавляется в первый.

#### Алгоритм

На практике не нужно создавать новый список для отсортированных элементов. В качестве него используется крайняя левая часть списка. Находится наименьший элемент и меняется с первым местами.

После того, как первый элемент списка отсортирован, находится наименьший элемент из оставшихся и меняем местами со вторым. Повторяется это до тех пор, пока не останется последний элемент в списке.

<details>
<summary>Реализация на Python</summary>

```

def selection_sort(nums):  
    for i in range(len(nums)):
        # По умолчанию первый элемент считается наименьшим
        lowest_value_index = i
        for j in range(i + 1, len(nums)):
            if nums[j] < nums[lowest_value_index]:
                lowest_value_index = j
        nums[i], nums[lowest_value_index] = nums[lowest_value_index], nums[i]
    return nums

```

</details>

<details>
<summary>Реализация на Ruby</summary>

```

def selection_sort(nums)
    nums.size.times do |i|
        # По умолчанию первый элемент считается наименьшим
        lowest_value_index = i
        (i + 1...nums.length).each do |j|
            if nums[j] < nums[lowest_value_index]
                lowest_value_index = j
            end
        end
        nums[i], nums[lowest_value_index] = nums[lowest_value_index], nums[i]
    end
    return nums
end

```

</details>


-------------------

### Пирамидальная сортировка

_Пирамидальная сортировка (сортировка кучей, HeapSort)_ - это метод сортировки сравнением, основанный на такой структуре данных как двоичная куча. Это такой же популярный алгоритм, как и сортировки вставками или выборкой. Алгоритм сегментирует список на две части: отсортированную и неотсортированную. Алгоритм преобразует второй сегмент списка в структуру данных «куча» (heap), чтобы можно было эффективно определить самый большой элемент.

#### Алгоритм

Сначала список преобразуется в Max Heap - бинарное дерево, где самый большой элемент является вершиной дерева. Затем этот элемент помещается в конец списка. После Max Heap перестраивается и снова новый наибольший элемент помещается уже перед последним элементом в списке.

Этот процесс построения кучи повторяется, пока все вершины дерева не будут удалены.

#### Время сортировки

В среднем время сортировки кучей составляет O(n log n), что значительно быстрее предыдущих алгоритмов.

<details>
<summary>Реализация на Python</summary>

```

def heapify(nums, heap_size, root_index):  
    # Индекс наибольшего элемента считаем корневым индексом
    largest = root_index
    left_child = (2 * root_index) + 1
    right_child = (2 * root_index) + 2

    # Если левый потомок корня - допустимый индекс, а элемент больше,
    # чем текущий наибольший, наибольший элемент обновляется
    if left_child < heap_size and nums[left_child] > nums[largest]:
        largest = left_child

    # То же самое для правого потомка корня
    if right_child < heap_size and nums[right_child] > nums[largest]:
        largest = right_child

    # Если наибольший элемент больше не корневой, они меняются местами
    if largest != root_index:
        nums[root_index], nums[largest] = nums[largest], nums[root_index]
        heapify(nums, heap_size, largest)

def heap_sort(nums):  
    n = len(nums)

    # Создаётся Max Heap из списка
    # Второй аргумент означает остановку алгоритма перед элементом -1, т.е.
    # перед первым элементом списка
    # 3-й аргумент означает повторный проход по списку в обратном направлении, 
    # уменьшая счётчик i на 1 
    for i in range(n, -1, -1):
        heapify(nums, n, i)

    # Перемещаем корень Max Heap в конец списка
    for i in range(n - 1, 0, -1):
        nums[i], nums[0] = nums[0], nums[i]
        heapify(nums, i, 0)

```

</details>

<details>
<summary>Реализация на Ruby</summary>

```



```

</details>


-------------------

### Сортировка слиянием

_Сортировка слиянием (merge sort)_ - алгоритм относится к алгоритмам «разделяй и властвуй». Алгоритм разбивает список на две части, каждую из них он разбивает ещё на две и т. д. Разбиение продолжается, пока не останутся единичные элементы.

Соседние элементы становятся отсортированными парами. Затем эти пары объединяются и сортируются с другими парами. Этот процесс продолжается до тех пор, пока не отсортируются все элементы.

#### Алгоритм

Список рекурсивно разделяется пополам, пока в итоге не получатся списки размером в один элемент. Массив из одного элемента считается упорядоченным. Соседние элементы сравниваются и соединяются вместе. Это происходит до тех пор, пока не получится полный отсортированный список.

Сортировка осуществляется путём сравнения наименьших элементов каждого подмассива. Первые элементы каждого подмассива сравниваются первыми. Наименьший элемент перемещается в результирующий массив. Счётчики результирующего массива и подмассива, откуда был взят элемент, увеличиваются на 1.

#### Время сортировки

В среднем время сортировки слиянием составляет O(n log n).

<details>
<summary>Реализация на Python</summary>

```

def merge(left_list, right_list):  
    sorted_list = []
    left_list_index = right_list_index = 0

    # Длина списков часто используется, поэтому для удобства создадются переменные
    left_list_length, right_list_length = len(left_list), len(right_list)

    for _ in range(left_list_length + right_list_length):
        if left_list_index < left_list_length and right_list_index < right_list_length:
            # Первые элементы в начале каждого списка сравниваются между собой
            # Если первый элемент левого подсписка меньше, он добавляется
            # в отсортированный массив
            if left_list[left_list_index] <= right_list[right_list_index]:
                sorted_list.append(left_list[left_list_index])
                left_list_index += 1
            # Если первый элемент правого подсписка меньше, он добавляется
            # в отсортированный массив
            else:
                sorted_list.append(right_list[right_list_index])
                right_list_index += 1

        # Если достигнут конец левого списка, элементы правого списка
        # добавляются в конец результирующего списка
        elif left_list_index == left_list_length:
            sorted_list.append(right_list[right_list_index])
            right_list_index += 1
        # Если достигнут конец правого списка, элементы левого списка
        # добавляются в отсортированный массив
        elif right_list_index == right_list_length:
            sorted_list.append(left_list[left_list_index])
            left_list_index += 1

    return sorted_list

def merge_sort(nums):  
    # Возвращается список, если он состоит из одного элемента
    if len(nums) <= 1:
        return nums

    # Для того чтобы найти середину списка, используется деление без остатка
    # Индексы должны быть целочисленные
    mid = len(nums) // 2

    # Сортировка и объединение подсписков
    left_list = merge_sort(nums[:mid])
    right_list = merge_sort(nums[mid:])

    # Объединение отсортированных списков в результирующий список
    return merge(left_list, right_list)

```

</details>

<details>
<summary>Реализация на Ruby</summary>

```



```

</details>


-------------------

### Быстрая сортировка

_Быстрая сортировка (quicksort)_ - этот алгоритм также относится к алгоритмам «разделяй и властвуй». Его используют чаще других алгоритмов. При правильной конфигурации он чрезвычайно эффективен и не требует дополнительной памяти, в отличие от той же сортировки слиянием. Массив разделяется на две части по разные стороны от опорного элемента. В процессе сортировки элементы меньше опорного помещаются перед ним, а равные или большие - позади.

Быстрая сортировка - один из самых быстрых известных универсальных алгоритмов сортировки массивов.

#### Алгоритм

Быстрая сортировка начинается с разбиения списка и выбора одного из элементов в качестве опорного. А всё остальное передвигается так, чтобы этот элемент встал на своё место. Все элементы меньше него перемещаются влево, а равные и большие элементы перемещаются вправо.

Если описывать работу чуть подробнее, то алгоритм состоит из трёх шагов:

1) Выбрать элемент из массива. Этот элемент называется опорным.
 
2) Разбиение. Перераспределение элементов в массиве таким образом, что элементы, меньшие опорного, помещаются перед ним, а большие или равные - после.

3) Рекурсивно применить первые два шага к двум подмассивам слева и справа от опорного элемента. Рекурсия не применяется к массиву, в котором только один элемент или отсутствуют элементы.

#### Время сортировки

В среднем время выполнения быстрой сортировки составляет O(n log n).

Алгоритм быстрой сортировки будет работать медленно, если опорный элемент равен наименьшему или наибольшему элементам списка. При таких условиях, в отличие от сортировок кучей и слиянием, обе из которых имеют в худшем случае время сортировки O(n log n), быстрая сортировка в худшем случае будет выполняться O(n²).

<details>
<summary>Реализация на Python</summary>

```

def partition(nums, low, high):  
    # В качестве опорного выбирается средний элемент
    pivot = nums[(low + high) // 2]
    i = low - 1
    j = high + 1
    while True:
        i += 1
        while nums[i] < pivot:
            i += 1

        j -= 1
        while nums[j] > pivot:
            j -= 1

        if i >= j:
            return j

        # Если элемент с индексом i (слева от опорного) больше, чем
        # элемент с индексом j (справа от опорного), элемены меняются местами
        nums[i], nums[j] = nums[j], nums[i]

def quick_sort(nums):  
    # Вспомогательная функцию, которая вызывается рекурсивно
    def _quick_sort(items, low, high):
        if low < high:
            split_index = partition(items, low, high)
            _quick_sort(items, low, split_index)
            _quick_sort(items, split_index + 1, high)

    _quick_sort(nums, 0, len(nums) - 1)

```

</details>

<details>
<summary>Реализация на Ruby</summary>

```



```

</details>
