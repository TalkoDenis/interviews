# Алгоритмы

Собрал немного материалов по алгоритмам. Знать их так или иначе нужно. Плюс иногда их спрашивают на собеседованиях. Постарался собрать материал от самого простого к сложному.

Реализация на Python и Ruby.

### Пузырьковая сортировка

_Пузырьковая сортировка (или иногда называют Сортировка пузырьком, bubble sort)_ - один из самых известных алгоритмов сортировки. Здесь последовательно сравниваются значения соседних элементов, и числа меняются местами, если предыдущее оказывается больше последующего. Таким образом элементы с большими значениями оказываются в конце списка, а с меньшими остаются в начале

#### Алгоритм
Сначала сравниваются первые два элемента списка. Если первый элемент больше второго, они меняются местами. Если элементы уже в нужном порядке, они остаются как есть. Затем необходимо перейти к следующей паре элементов, сравнить их значения и поменяем местами при необходимости. Этот процесс продолжается до последней пары элементов в списке.

При достижении конца списка процесс повторяется заново для каждого элемента. Это крайне неэффективно, если в массиве нужно сделать, например, только один обмен. Алгоритм повторяется n² раз, даже если список уже отсортирован.

Для оптимизации алгоритма нужно знать, когда его остановить, то есть когда список отсортирован.

Чтобы остановить алгоритм по окончанию сортировки, нужно ввести переменную-флаг. Когда значения меняются местами, флаг устанавливается в значение True, чтобы повторить процесс сортировки. Если перестановок не произошло, флаг остаётся False и алгоритм останавливается.

Алгоритм работает в цикле while и прерывается, когда элементы ни разу не меняются местами. Вначале swapped присваивается значение True, чтобы алгоритм запустился хотя бы один раз.


#### Время сортировки
Если взять самый худший случай (изначально список отсортирован по убыванию), затраты времени будут равны O(n²), где n - количество элементов списка.

Этот алгоритм считается учебным и почти не применяется на практике из-за низкой эффективности: он медленно работает на тестах, в которых маленькие элементы стоят в конце массива. Однако на нём основаны многие другие методы, например, _шейкерная сортировка_ и _сортировка расчёской_. Об этих алгоритмах будет написано далее.


<details>
<summary>Реализация на Python</summary>

```
def bubble_sort(nums):  
    # swapped установлен в True, чтобы цикл запустился хотя бы один раз
    swapped = True
    while swapped:
        swapped = False
        for i in range(len(nums) - 1):
            if nums[i] > nums[i + 1]:
                # Элементы меняются местами
                nums[i], nums[i + 1] = nums[i + 1], nums[i]
                # Устанавливаем swapped в True для следующей итерации
                swapped = True
    return nums
```

</details>

<details>
<summary>Реализация на Ruby</summary>

```
def bubble_sort(nums)
    # swapped установлен в true, чтобы цикл запустился хотя бы один раз
    swapped = true
    # определяется размер списка
    nums_length = nums.size
    while swapped
        swapped = false
        (nums_length - 1).times do |i|
            if nums[i] > nums[i + 1]
                # Элементы меняются местами
                nums[i], nums[i + 1] = nums[i + 1], nums[i]
                # Устанавливаем swapped в True для следующей итерации
                swapped = true
            end
        end
    end
    return nums
end
```

</details>






https://tproger.ru/translations/sorting-algorithms-in-python



### Шейкерная сортировка

_Сортировка перемешиванием (шейкерная сортировка, cocktail sort, shaker sort)_ – это усовершенствованная разновидность сортировки пузырьком, при которой сортировка производиться в двух направлениях, меняя направление при каждом проходе.

Проанализировав алгоритм пузырьковой сортировки, можно заметить следующее:

если при обходе части массива не было обменов элементов, то эту часть можно исключить, так как она уже отсортирована;

при проходе от конца массива к началу минимальное значение сдвигается на первую позицию, при этом максимальный элемент перемещается только на один индекс вправо.

#### Алгоритм

Данный тип сортировки представляет собой улучшенный вариант пузырькового способа упорядочивания данных. Он является двунаправленным. Принцип данной сотрировки состоит в том, что проход делается сначала в одну сторону массива, сравнивая и сортируя по очереди соседние два числа массива, и когда алгоритм доходит до конца массива, наиболее крупное число оказывается в правой его части.

В пузырьковой сортировке происходит возврат в начало массива и все повторялось заново. В этом методе возврат не производится, а происходит переход влево, попарно сравнивая соседние элементы. Результатом прохода в левую сторону станет минимальное число, которое выводится в начало массива. Затем снова начинается движение вправо, сортируя и выводя предпоследнее число результирующего массива. Дойдя до конца, направление сортировки снова меняется, и процесс продолжает выполнять действия до тех пор, пока массив не будет отсортирован.

#### Время сортировки
Как и в случае с сортировкой пузырьком, при самом худшем сценарии затраты времени будут равны O(n²), где n - количество элементов списка. Но всё же этот алгоритм чуть совершеннее и работает несколько быстрее.

<details>
<summary>Реализация на Python</summary>

```
def shaker_sort(nums): 
    # Определяем начальный (левый) и конечный (правый) элементы
    left = 0
    right = len(nums) - 1
    while left <= right:
        # Проходимся от левого до правого элемента с шагом один
        for i in range(left, right, 1):
            if nums[i] > nums[i + 1]:
                nums[i], nums[i + 1] = nums[i + 1], nums[i]
        right -= 1
        # Проходимся от правого до левого элемента с шагом минус один!
        for i in range(right, left, -1):
            if nums[i - 1] > nums[i]:
                nums[i], nums[i - 1] = nums[i - 1], nums[i]
        left += 1
    return nums
```

</details>

<details>
<summary>Реализация на Ruby</summary>

```
def shaker_sort(nums) 
    # Определяем начальный (левый) и конечный (правый) элементы
    left = 0
    right = nums.size - 1
    while left <= right
        # Проходимся от левого до правого элемента с шагом один
        (left...right).each do |i|
            if nums[i] > nums[i + 1]
                nums[i], nums[i + 1] = nums[i + 1], nums[i]
            end
        right -= 1
        end
        # Проходимся от правого до левого элемента с шагом минус один!
        (right).downto(left).each do |i|
            if nums[i - 1] > nums[i]
                nums[i], nums[i - 1] = nums[i - 1], nums[i]
            end
        left += 1
        end
    end
    return nums
end
```

</details>


